<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8" />
  <title>Babylon â€” 3rd Person Sphere</title>
  <link rel="icon" href="awodas.png" type="image/png">
  <style>
    html,body { width:100%; height:100%; margin:0; overflow:hidden; }
    #renderCanvas { width:100%; height:100%; touch-action:none; display:block; }
  </style>

  <!-- Babylon -->
  <script src="https://cdn.babylonjs.com/babylon.js"></script>

  <!-- Water Material -->
  <script src="https://cdn.babylonjs.com/materialsLibrary/babylon.waterMaterial.min.js"></script>

  <!-- Earcut -->
  <script src="https://cdn.babylonjs.com/earcut.min.js"></script>

  <!-- Physics -->
  <script src="https://cdn.babylonjs.com/cannon.js"></script>
</head>
<body>
<canvas id="renderCanvas"></canvas>

<script>
/* ============================================================
   INIT
============================================================ */
const canvas = document.getElementById("renderCanvas");
const engine = new BABYLON.Engine(canvas, true);

const SETTINGS = {
  groundTopColor:  "#33FF4B",
  groundSideColor: "#8B5A2B",
  waterColor:      "#4DA6FF",
  skyColor:        "#9DE9FF",

  cubeCount: 30,
  respawnY: -25,

  moveForce: 7.5,
  maxSpeed:  8,
  jumpForce: 6.2,
  damp: 0.92,

  coatTexture: "box-texture.png",
  coatSize:    2.04,
  cubeSize:    2,
  safeRadius:  8,

  swimUpSpeed: 4
};

const RAMPS = [
  { x: 20,  z: 20,  rotY: 0 },
  { x: -30, z: -10, rotY: Math.PI/2 },
  { x: 40,  z: -40, rotY: Math.PI/3 }
];

/* ============================================================
   TRIANGULAR RAMP
============================================================ */
function makeTriRamp(scene) {
  const shape = [
    new BABYLON.Vector2(0,0),
    new BABYLON.Vector2(10,0),
    new BABYLON.Vector2(10,6),
    new BABYLON.Vector2(0,6)
  ];

  const depth = 4;

  const ramp = BABYLON.MeshBuilder.ExtrudePolygon(
    "triRamp",
    { shape, depth, sideOrientation: BABYLON.Mesh.DOUBLESIDE },
    scene
  );

  ramp.rotation.x = -Math.atan2(depth, 6);

  const m = new BABYLON.StandardMaterial("rampMat", scene);
  m.diffuseColor = BABYLON.Color3.Random();
  ramp.material = m;

  ramp.physicsImpostor = new BABYLON.PhysicsImpostor(
    ramp,
    BABYLON.PhysicsImpostor.MeshImpostor,
    { mass: 0, friction: 1, restitution: 0 },
    scene
  );

  return ramp;
}

/* ============================================================
   CREATE SCENE
============================================================ */
function createScene() {
  const scene = new BABYLON.Scene(engine);
  scene.clearColor = BABYLON.Color3.FromHexString(SETTINGS.skyColor);

  new BABYLON.HemisphericLight("light", new BABYLON.Vector3(0,1,0), scene);

  scene.enablePhysics(new BABYLON.Vector3(0, -9.81, 0), new BABYLON.CannonJSPlugin());

/* ============================================================
   SOLID GROUND BOX
============================================================ */
const ground = BABYLON.MeshBuilder.CreateBox("ground", {
  width: 300,
  height: 10,
  depth: 300
}, scene);

ground.position.y = -5;

const matTop = new BABYLON.StandardMaterial("matTop", scene);
matTop.diffuseColor = BABYLON.Color3.FromHexString(SETTINGS.groundTopColor);

const matSide = new BABYLON.StandardMaterial("matSide", scene);
matSide.diffuseColor = BABYLON.Color3.FromHexString(SETTINGS.groundSideColor);

const multi = new BABYLON.MultiMaterial("groundMulti", scene);
multi.subMaterials = [matSide,matSide,matSide,matSide,matTop,matSide];
ground.material = multi;

ground.subMeshes = [];
const vertices = ground.getTotalVertices();
let indexStart = 0;
for (let f = 0; f < 6; f++) {
  new BABYLON.SubMesh(f, 0, vertices, indexStart, 6, ground);
  indexStart += 6;
}

ground.physicsImpostor = new BABYLON.PhysicsImpostor(
  ground,
  BABYLON.PhysicsImpostor.BoxImpostor,
  { mass: 0, friction: 2, restitution: 0 },
  scene
);

/* ============================================================
   WATER
============================================================ */
const water = BABYLON.MeshBuilder.CreateGround("water", {
  width: 700,
  height: 700
}, scene);

water.position.y = -6.5;

const waterMat = new BABYLON.WaterMaterial("waterMat", scene);
waterMat.waveHeight = 0.4;
waterMat.windForce = 3;
waterMat.waterColor = new BABYLON.Color3.FromHexString(SETTINGS.waterColor);

water.material = waterMat;
waterMat.addToRenderList(ground);

/* ============================================================
   PLAYER SPHERE
============================================================ */
const sphere = BABYLON.MeshBuilder.CreateSphere("player", { diameter:2 }, scene);
sphere.position.set(0,3,0);

const sphereMat = new BABYLON.StandardMaterial("sphereMat", scene);
sphereMat.diffuseColor = BABYLON.Color3.Random();
sphere.material = sphereMat;

sphere.physicsImpostor = new BABYLON.PhysicsImpostor(
  sphere,
  BABYLON.PhysicsImpostor.SphereImpostor,
  { mass:1, friction:0.6, restitution:0.05 },
  scene
);

/* ============================================================
   TRI RAMP SPAWN (FIXED Y POSITION)
============================================================ */
const ramps = RAMPS.map(r=>{
  const ramp = makeTriRamp(scene);
  ramp.position.set(r.x, 0.1, r.z); // FIX: sits on ground, never inside
  ramp.rotation.y = r.rotY;
  return ramp;
});

function onRampBoost() {
  const v = sphere.physicsImpostor.getLinearVelocity();
  sphere.physicsImpostor.setLinearVelocity(new BABYLON.Vector3(v.x, 10, v.z));
}

/* ============================================================
   RANDOM CUBES (RESTORED)
============================================================ */
const cubes = [];
for (let i = 0; i < SETTINGS.cubeCount; i++) {
  const c = BABYLON.MeshBuilder.CreateBox("cube" + i, {
    size: SETTINGS.cubeSize
  }, scene);

  c.position.x = (Math.random() * 200 - 100);
  c.position.z = (Math.random() * 200 - 100);
  c.position.y = 1;

  const m = new BABYLON.StandardMaterial("cubeMat" + i, scene);
  m.diffuseColor = BABYLON.Color3.Random();
  c.material = m;

  c.physicsImpostor = new BABYLON.PhysicsImpostor(
    c,
    BABYLON.PhysicsImpostor.BoxImpostor,
    { mass: 0, friction: 0.7, restitution: 0.1 },
    scene
  );

  cubes.push(c);
}

/* ============================================================
   MOVEMENT ARROWS (RESTORED)
============================================================ */
const arrowMat = new BABYLON.StandardMaterial("arrowMat", scene);
arrowMat.diffuseColor = BABYLON.Color3.White();

function makeArrow(name, angle, x, z) {
  const p = BABYLON.MeshBuilder.CreatePlane(name, { size: 1 }, scene);
  p.rotation.x = -Math.PI / 2;
  p.rotation.y = angle;
  p.position.set(x, 0.05, z);
  p.material = arrowMat;
  return p;
}

const arrows = {
  w: makeArrow("arrowW", 0,       0,  2),
  s: makeArrow("arrowS", Math.PI, 0, -2),
  d: makeArrow("arrowD", Math.PI/2,  2, 0),
  a: makeArrow("arrowA", -Math.PI/2, -2, 0)
};

/* ============================================================
   INPUT
============================================================ */
const input = {forward:false,back:false,left:false,right:false,jump:false};
window.addEventListener("keydown", e=>{
  const k=e.key.toLowerCase();
  if(k==="w")input.forward=true;
  if(k==="s")input.back=true;
  if(k==="a")input.left=true;
  if(k==="d")input.right=true;
  if(k===" ")input.jump=true;
});
window.addEventListener("keyup", e=>{
  const k=e.key.toLowerCase();
  if(k==="w")input.forward=false;
  if(k==="s")input.back=false;
  if(k==="a")input.left=false;
  if(k==="d")input.right=false;
  if(k===" ")input.jump=false;
});

/* ============================================================
   CAMERA
============================================================ */
const camera = new BABYLON.ArcRotateCamera(
  "cam",
  0,
  BABYLON.Tools.ToRadians(55),
  12,
  sphere.position.clone(),
  scene
);
camera.attachControl(canvas,true);

/* ============================================================
   GAME LOOP
============================================================ */
let lastMove = new BABYLON.Vector3(0,0,1);
const worldForward = new BABYLON.Vector3(0,0,1);
const worldRight   = new BABYLON.Vector3(1,0,0);

function grounded(){
  const ray = new BABYLON.Ray(sphere.position, new BABYLON.Vector3(0,-1,0), 1.2);
  const hit = scene.pickWithRay(ray, m=>m!==sphere);
  return hit && hit.hit;
}

function clampVel(v){
  const h = new BABYLON.Vector3(v.x,0,v.z);
  const l = h.length();
  if(l > SETTINGS.maxSpeed){
    h.scaleInPlace(SETTINGS.maxSpeed/l);
    return new BABYLON.Vector3(h.x,v.y,h.z);
  }
  return v;
}

scene.registerBeforeRender(()=>{
  let dir = BABYLON.Vector3.Zero();
  if(input.forward) dir.addInPlace(worldForward);
  if(input.back)    dir.subtractInPlace(worldForward);
  if(input.left)    dir.subtractInPlace(worldRight);
  if(input.right)   dir.addInPlace(worldRight);

  if(dir.lengthSquared()>0.001){
    dir.normalize();
    lastMove.copyFrom(dir);
  }

  const v = sphere.physicsImpostor.getLinearVelocity();
  const damped = new BABYLON.Vector3(v.x*SETTINGS.damp, v.y, v.z*SETTINGS.damp);

  if(dir.length()>0.001){
    sphere.physicsImpostor.setLinearVelocity(
      clampVel(damped.add(dir.scale(SETTINGS.moveForce * engine.getDeltaTime()*0.06)))
    );
  } else {
    sphere.physicsImpostor.setLinearVelocity(new BABYLON.Vector3(damped.x,v.y,damped.z));
  }

  /* JUMP (RESTORED) */
  if(input.jump && grounded()){
    const v2 = sphere.physicsImpostor.getLinearVelocity();
    sphere.physicsImpostor.setLinearVelocity(new BABYLON.Vector3(v2.x, SETTINGS.jumpForce, v2.z));
  }

  /* SWIM */
  if(sphere.position.y < water.position.y + 1){
    sphere.physicsImpostor.setLinearVelocity(
      new BABYLON.Vector3(v.x*0.9, v.y+0.08, v.z*0.9)
    );
    if(input.jump){
      sphere.physicsImpostor.setLinearVelocity(
        new BABYLON.Vector3(v.x, SETTINGS.swimUpSpeed, v.z)
      );
    }
  }

  /* RAMP BOOST */
  for(const ramp of ramps){
    if(BABYLON.Vector3.Distance(sphere.position, ramp.position) < 6){
      onRampBoost();
    }
  }

  /* RESPAWN */
  if(sphere.position.y < SETTINGS.respawnY){
    sphere.position.set(0,6,0);
    sphere.physicsImpostor.setLinearVelocity(BABYLON.Vector3.Zero());
  }

  /* CAMERA FOLLOW */
  camera.target = BABYLON.Vector3.Lerp(camera.target, sphere.position, 0.35);
});

return scene;
}

/* ============================================================
   START ENGINE
============================================================ */
const scene = createScene();
engine.runRenderLoop(() => scene.render());
window.addEventListener("resize", () => engine.resize());
</script>
</body>
</html>
