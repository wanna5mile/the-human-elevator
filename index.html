<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8" />
  <title>Babylon — 3rd Person Sphere (Multiplayer, Fixed Ramps, Rings, Trees, Day/Night, Pyramids)</title>
  <link rel="icon" href="awodas.png" type="image/png">
  <style>
    html,body { width:100%; height:100%; margin:0; overflow:hidden; font-family: Inter, system-ui, sans-serif; }
    #renderCanvas { width:100%; height:100%; touch-action:none; display:block; }
    #ui { position: absolute; left: 12px; top: 12px; z-index: 50; color: white; text-shadow: 0 2px 6px rgba(0,0,0,0.7); user-select: none; }
    #coinCounter { background: rgba(0,0,0,0.45); padding: 10px 14px; border-radius: 8px; font-size: 18px; min-width: 120px; }
    #multiplier { margin-top: 8px; background: rgba(0,0,0,0.35); padding: 8px 12px; border-radius: 8px; font-size: 14px; }
    #netUI { position: absolute; right: 12px; top: 12px; z-index: 50; color: white; font-size: 13px; }
    #netUI input { padding:6px; border-radius:6px; border:none; margin-right:6px; }
    #netUI button { padding:6px 10px; border-radius:6px; border:none; cursor:pointer; }
    #otherPlayersLabel { position: absolute; right: 12px; top: 70px; z-index: 50; color: white; font-size: 13px; background: rgba(0,0,0,0.35); padding:8px; border-radius:8px; }
  </style>

  <!-- Babylon -->
  <script src="https://cdn.babylonjs.com/babylon.js"></script>
  <!-- Water Material -->
  <script src="https://cdn.babylonjs.com/materialsLibrary/babylon.waterMaterial.min.js"></script>
  <!-- Earcut -->
  <script src="https://cdn.babylonjs.com/earcut.min.js"></script>
  <!-- Physics (Cannon) -->
  <script src="https://cdn.babylonjs.com/cannon.js"></script>
</head>
<body>
<canvas id="renderCanvas"></canvas>

<div id="ui">
  <div id="coinCounter">Coins: <span id="coinsValue">0</span></div>
  <div id="multiplier" style="display:none;">Multiplier: <span id="multValue">2x</span> — <span id="multTime">30</span>s</div>
</div>

<div id="netUI">
  <input id="roomInput" placeholder="room id (optional)" />
  <input id="serverInput" placeholder="ws://localhost:8080 (leave blank to use ws://localhost:8080)" style="width:220px"/>
  <button id="connectBtn">Connect</button>
  <div id="netStatus" style="margin-top:6px;font-size:12px;opacity:0.9"></div>
</div>

<div id="otherPlayersLabel" style="display:none;">Other Players: <span id="otherCount">0</span></div>

<script>
/* ============================================================
   INIT + SETTINGS
============================================================ */
const canvas = document.getElementById("renderCanvas");
const engine = new BABYLON.Engine(canvas, true);

const SETTINGS = {
  groundTopColor:  "#33FF4B",
  groundSideColor: "#8B5A2B",
  waterColor:      "#4DA6FF",
  skyColor:        "#9DE9FF",

  cubeCount: 30,
  hillCount: 10,
  treeCount: 40,
  respawnY: -60,

  moveForce: 7.5,
  maxSpeed:  8,
  jumpForce: 6.6,
  damp: 0.92,

  cubeSize:    2,
  safeRadius:  8,

  swimUpSpeed: 4,
  coinMax: 32,
  coinRespawnSec: 45,

  ringRadius: 5.0,
  ringThickness: 0.6,
  ringHeightOffset: 6.0,
  ringProximity: 4.0,
  ringHeightTolerance: 3.0,
  ringMultiplier: 2,
  ringDurationSec: 30
};

const SPAWN_ZONES = [
  { x: 0,  z: 0,  r: 12 },
  { x: 60, z: 40, r: 12 },
  { x: -60,z: -40,r: 12 }
];

const RAMPS = [
  { x: 20,  z: 20,  rotY: 0 },
  { x: -30, z: -10, rotY: Math.PI/2 },
  { x: 40,  z: -40, rotY: Math.PI/3 }
];

function rndRange(min,max){ return Math.random()*(max-min)+min; }

function makeTriRamp(scene) {
  const shape = [
    new BABYLON.Vector2(0,0),
    new BABYLON.Vector2(10,0),
    new BABYLON.Vector2(10,6),
    new BABYLON.Vector2(0,6)
  ];
  const depth = 4;
  const ramp = BABYLON.MeshBuilder.ExtrudePolygon("triRamp",{shape, depth, sideOrientation: BABYLON.Mesh.DOUBLESIDE}, scene);
  ramp.rotation.x = -Math.atan2(depth,6);
  const m = new BABYLON.StandardMaterial("rampMat", scene);
  m.diffuseColor = BABYLON.Color3.Random();
  ramp.material = m;
  ramp.physicsImpostor = new BABYLON.PhysicsImpostor(ramp, BABYLON.PhysicsImpostor.MeshImpostor, { mass:0, friction:1, restitution:0 }, scene);
  ramp._rampParams = { depth, shapeWidth:10, shapeHeight:6 };
  return ramp;
}

/* ============================================================
   MAIN SCENE
============================================================ */
function createScene(){
  const scene = new BABYLON.Scene(engine);
  scene.clearColor = BABYLON.Color3.FromHexString(SETTINGS.skyColor);
  scene.enablePhysics(new BABYLON.Vector3(0,-9.81,0), new BABYLON.CannonJSPlugin());

  // ===== DAY / NIGHT SYSTEM =====
  const sun = new BABYLON.DirectionalLight("sun", new BABYLON.Vector3(-1,-2,-1), scene);
  sun.position = new BABYLON.Vector3(50, 100, 50);
  sun.intensity = 1.2;
  let dayTime = 0;
  scene.registerBeforeRender(()=>{
    dayTime += engine.getDeltaTime()*0.00002;
    if(dayTime>1) dayTime=0;
    const angle = dayTime * Math.PI*2;
    sun.direction = new BABYLON.Vector3(Math.sin(angle), -Math.cos(angle), Math.cos(angle));
    sun.intensity = BABYLON.Scalar.Clamp(Math.cos(angle)+0.3,0.1,1.2);
    const dayColor = new BABYLON.Color3(0.6,0.9,1);
    const nightColor = new BABYLON.Color3(0.02,0.02,0.1);
    const blend = BABYLON.Scalar.Clamp(Math.cos(angle)+0.5,0,1);
    scene.clearColor = BABYLON.Color3.Lerp(nightColor,dayColor,blend);
  });

  /* ---------------- GROUND ---------------- */
  const groundSize = 300;
  const groundHeight = 10;
  const ground = BABYLON.MeshBuilder.CreateBox("ground",{width:groundSize,height:groundHeight,depth:groundSize},scene);
  ground.position.y = -groundHeight/2;
  const matTop = new BABYLON.StandardMaterial("matTop", scene);
  matTop.diffuseColor = BABYLON.Color3.FromHexString(SETTINGS.groundTopColor);
  const matSide = new BABYLON.StandardMaterial("matSide", scene);
  matSide.diffuseColor = BABYLON.Color3.FromHexString(SETTINGS.groundSideColor);
  const multi = new BABYLON.MultiMaterial("groundMulti", scene);
  multi.subMaterials = [matSide, matSide, matSide, matSide, matTop, matSide];
  ground.material = multi;
  ground.subMeshes = [];
  const vertices = ground.getTotalVertices();
  let indexStart = 0;
  for(let f=0; f<6; f++){ new BABYLON.SubMesh(f,0,vertices,indexStart,6,ground); indexStart+=6; }
  ground.physicsImpostor = new BABYLON.PhysicsImpostor(ground, BABYLON.PhysicsImpostor.BoxImpostor,{ mass:0, friction:2, restitution:0 },scene);

  /* ---------------- PLAYER ---------------- */
  const sphere = BABYLON.MeshBuilder.CreateSphere("player",{diameter:2},scene);
  sphere.position.set(0,3,0);
  const sphereMat = new BABYLON.StandardMaterial("sphereMat", scene);
  sphereMat.diffuseColor = new BABYLON.Color3(0.2,0.6,1);
  sphere.material = sphereMat;
  sphere.physicsImpostor = new BABYLON.PhysicsImpostor(sphere, BABYLON.PhysicsImpostor.SphereImpostor,{ mass:1, friction:0.6, restitution:0.05 },scene);

  /* ---------------- RAMPS ---------------- */
  const ramps=[]; const rampTriggers=[];
  for(const r of RAMPS){
    const ramp=makeTriRamp(scene);
    ramp.position.set(r.x,1.8,r.z);
    ramp.rotation.y = r.rotY;
    ramps.push(ramp);
    const depth = ramp._rampParams.depth || 4;
    const forward = new BABYLON.Vector3(Math.sin(r.rotY),0,Math.cos(r.rotY));
    const worldTrigger = ramp.position.add(forward.scale((depth/2)+1.5)).add(new BABYLON.Vector3(0,1.8,0));
    rampTriggers.push({ ramp, worldTrigger, forward });
  }
  function onRampBoost(trigger){
    const v = sphere.physicsImpostor.getLinearVelocity();
    const impulse = trigger.forward.normalize().scale(8);
    sphere.physicsImpostor.setLinearVelocity(new BABYLON.Vector3(impulse.x,12,impulse.z));
  }

  /* ---------------- PYRAMIDS ---------------- */
  const pyramids = [];
  const pyramidCount = 12;
  for(let i=0;i<pyramidCount;i++){
    let x,z,tries=0;
    do{
      x=rndRange(-groundSize/2+10,groundSize/2-10);
      z=rndRange(-groundSize/2+10,groundSize/2-10);
      tries++;
    } while(Math.hypot(x,z)<SETTINGS.safeRadius && tries<200);
    const pyramid=BABYLON.MeshBuilder.CreateCylinder("pyramid"+i,{diameterTop:0,diameterBottom:6,height:6,tessellation:4},scene);
    pyramid.position.set(x,3,z);
    const pMat = new BABYLON.StandardMaterial("pMat"+i,scene);
    pMat.diffuseColor = new BABYLON.Color3(0.9,0.75,0.3);
    pyramid.material=pMat;
    pyramid.physicsImpostor = new BABYLON.PhysicsImpostor(pyramid,BABYLON.PhysicsImpostor.MeshImpostor,{mass:0,friction:1,restitution:0},scene);
    pyramids.push(pyramid);
  }

  /* ---------------- TREES ---------------- */
  const trees=[]; // same as your previous code
  for(let i=0;i<SETTINGS.treeCount;i++){
    let x,z,tries=0;
    do{ x=rndRange(-groundSize/2+8,groundSize/2-8); z=rndRange(-groundSize/2+8,groundSize/2-8); tries++; }
    while((Math.hypot(x,z)<18 || SPAWN_ZONES.some(s=>Math.hypot(x-s.x,z-s.z)<s.r+4)) && tries<400);
    const trunk = BABYLON.MeshBuilder.CreateCylinder("trunk"+i,{height:3,diameterTop:0.6,diameterBottom:0.8,tessellation:8},scene);
    trunk.position.set(x,1.5,z);
    const trunkM = new BABYLON.StandardMaterial("trunkM"+i,scene); trunkM.diffuseColor=new BABYLON.Color3(0.35,0.25,0.12); trunk.material=trunkM;
    trunk.physicsImpostor = new BABYLON.PhysicsImpostor(trunk,BABYLON.PhysicsImpostor.NoImpostor,{mass:0});
    const foliage = BABYLON.MeshBuilder.CreateCylinder("leaf"+i,{height:4,diameterTop:0,diameterBottom:3,tessellation:12},scene);
    foliage.position.set(x,4.0,z); foliage.rotation.x=0;
    const leafM = new BABYLON.StandardMaterial("leafM"+i,scene); leafM.diffuseColor=BABYLON.Color3.FromHexString(SETTINGS.groundTopColor); foliage.material=leafM;
    foliage.physicsImpostor = new BABYLON.PhysicsImpostor(foliage,BABYLON.PhysicsImpostor.NoImpostor,{mass:0});
    trees.push({trunk,foliage});
  }

  /* ---------------- CAMERA ---------------- */
  const camera = new BABYLON.ArcRotateCamera("cam",0,BABYLON.Tools.ToRadians(55),14,sphere.position.clone(),scene);
  camera.attachControl(canvas,true);
  camera.lowerRadiusLimit=6; camera.upperRadiusLimit=40;

/* ============================================================
   MAIN GAME LOOP (movement, coins, ramps, rings, etc)
============================================================ */
let lastMove = new BABYLON.Vector3(0,0,1);
const worldForward = new BABYLON.Vector3(0,0,1);
const worldRight   = new BABYLON.Vector3(1,0,0);

function grounded(){
  const ray = new BABYLON.Ray(sphere.position, new BABYLON.Vector3(0,-1,0), 1.2);
  const hit = scene.pickWithRay(ray, m => m !== sphere);
  return hit && hit.hit;
}

function clampVel(v){
  const h = new BABYLON.Vector3(v.x,0,v.z);
  const l = h.length();
  if(l > SETTINGS.maxSpeed){
    h.scaleInPlace(SETTINGS.maxSpeed/l);
    return new BABYLON.Vector3(h.x, v.y, h.z);
  }
  return v;
}

scene.registerBeforeRender(()=>{
  updateArrows(input);

  // movement dir (world-space)
  let dir = BABYLON.Vector3.Zero();
  if(input.forward) dir.addInPlace(worldForward);
  if(input.back)    dir.subtractInPlace(worldForward);
  if(input.left)    dir.subtractInPlace(worldRight);
  if(input.right)   dir.addInPlace(worldRight);

  if(dir.lengthSquared() > 0.001){
    dir.normalize();
    lastMove.copyFrom(dir);
  }

  // physics velocity & damping
  const v = sphere.physicsImpostor.getLinearVelocity();
  const damped = new BABYLON.Vector3(v.x*SETTINGS.damp, v.y, v.z*SETTINGS.damp);

  if(dir.length()>0.001){
    sphere.physicsImpostor.setLinearVelocity(
      clampVel(damped.add(dir.scale(SETTINGS.moveForce * engine.getDeltaTime()*0.06)))
    );
  } else {
    sphere.physicsImpostor.setLinearVelocity(new BABYLON.Vector3(damped.x, v.y, damped.z));
  }

  // jump (on ground)
  if(input.jump && grounded()){
    const v2 = sphere.physicsImpostor.getLinearVelocity();
    sphere.physicsImpostor.setLinearVelocity(new BABYLON.Vector3(v2.x, SETTINGS.jumpForce, v2.z));
  }

  // swim behaviour
  const swimThreshold = water.position.y + 1.2;
  if(sphere.position.y < swimThreshold){
    sphere.physicsImpostor.setLinearVelocity(new BABYLON.Vector3(v.x * 0.9, v.y + 0.08, v.z * 0.9));
    if(input.jump){
      sphere.physicsImpostor.setLinearVelocity(new BABYLON.Vector3(v.x, SETTINGS.swimUpSpeed, v.z));
    }
  }

  // ramp boost detection (use trigger points computed earlier)
  for(const trig of rampTriggers){
    const d = BABYLON.Vector3.Distance(new BABYLON.Vector3(sphere.position.x, 0, sphere.position.z), new BABYLON.Vector3(trig.worldTrigger.x, 0, trig.worldTrigger.z));
    if(d < 3.2 && Math.abs(sphere.position.y - trig.worldTrigger.y) < 3.0){
      onRampBoost(trig);
    }
  }

  // ring detection
  for(const ring of rings){
    const dx = sphere.position.x - ring.center.x;
    const dz = sphere.position.z - ring.center.z;
    const horizDist = Math.hypot(dx, dz);
    const heightDiff = Math.abs(sphere.position.y - ring.center.y);
    if(horizDist < SETTINGS.ringProximity && heightDiff < SETTINGS.ringHeightTolerance){
      if(!ring.usedBy.has(playerId)){
        grantMultiplier(SETTINGS.ringDurationSec);
        ring.usedBy.add(playerId);

        const s = ring.mesh;
        const now = Date.now();
        BABYLON.Animation.CreateAndStartAnimation("pX"+now, s, "scaling.x", 30, 12, s.scaling.x, s.scaling.x*1.35, BABYLON.Animation.ANIMATIONLOOPMODE_YOYO);
        BABYLON.Animation.CreateAndStartAnimation("pY"+now, s, "scaling.y", 30, 12, s.scaling.y, s.scaling.y*1.35, BABYLON.Animation.ANIMATIONLOOPMODE_YOYO);
        BABYLON.Animation.CreateAndStartAnimation("pZ"+now, s, "scaling.z", 30, 12, s.scaling.z, s.scaling.z*1.35, BABYLON.Animation.ANIMATIONLOOPMODE_YOYO);
      }
    } else {
      if(ring.usedBy.has(playerId)){
        ring.usedBy.delete(playerId);
      }
    }
  }

  // coin pickup detection
  for(let i=0;i<coins.length;i++){
    const coin = coins[i];
    if(!coin || !coin.mesh || !coin.mesh.isVisible) continue;
    const d = Math.hypot(coin.mesh.position.x - sphere.position.x, coin.mesh.position.z - sphere.position.z);
    const heightDiff = Math.abs(coin.mesh.position.y - sphere.position.y);
    if(d < 1.3 && heightDiff < 2.2){
      if(socket && socket.readyState === WebSocket.OPEN){
        socket.send(JSON.stringify({ type: "collect", id: coin.id, player: playerId, room }));
      } else {
        coin.mesh.isVisible = false;
        coin.active = false;
        let award = 1;
        if(multiplierActive && Date.now() < multiplierExpireAt) award *= SETTINGS.ringMultiplier;
        coinsCollected += award;
        coinCounterEl.textContent = coinsCollected;
        setTimeout(()=> hideAndScheduleRespawnLocal(coin.id), SETTINGS.coinRespawnSec*1000);
      }
    }
  }

  // multiplier UI update
  if(multiplierActive){
    const remaining = Math.max(0, Math.ceil((multiplierExpireAt - Date.now())/1000));
    multTimeEl.textContent = remaining;
    if(remaining <= 0) setMultiplierActive(false);
  }

  // respawn safeguards
  if(sphere.position.y < SETTINGS.respawnY){
    sphere.position.set(0,6,0);
    sphere.physicsImpostor.setLinearVelocity(BABYLON.Vector3.Zero());
  }

  // camera follow
  camera.target = BABYLON.Vector3.Lerp(camera.target, sphere.position, 0.35);

  // occasionally send our state
  if(Math.random() < 0.06) sendState();

  // cleanup stale remote players
  const now = Date.now();
  for(const [id,op] of Array.from(otherPlayers.entries())){
    if(now - op.lastUpdated > 12000){
      try { op.mesh.dispose(); } catch(e){}
      otherPlayers.delete(id);
    }
  }
  otherCountEl.textContent = otherPlayers.size;
  otherPlayersLabel.style.display = otherPlayers.size>0 ? "block" : "none";
});

  return scene;
}

/* ============================================================
   START ENGINE
============================================================ */
const scene = createScene();
engine.runRenderLoop(()=> scene.render());
window.addEventListener("resize",()=>engine.resize());
</script>
</body>
</html>
