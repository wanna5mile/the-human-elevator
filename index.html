<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8" />
  <title>Babylon — 3rd Person Sphere (Multiplayer, Fixed Ramps, Rings, Trees)</title>
  <link rel="icon" href="awodas.png" type="image/png">
  <style>
    html,body { width:100%; height:100%; margin:0; overflow:hidden; font-family: Inter, system-ui, sans-serif; }
    #renderCanvas { width:100%; height:100%; touch-action:none; display:block; }
    #ui { position: absolute; left: 12px; top: 12px; z-index: 50; color: white; text-shadow: 0 2px 6px rgba(0,0,0,0.7); user-select: none; }
    #coinCounter { background: rgba(0,0,0,0.45); padding: 10px 14px; border-radius: 8px; font-size: 18px; min-width: 120px; }
    #multiplier { margin-top: 8px; background: rgba(0,0,0,0.35); padding: 8px 12px; border-radius: 8px; font-size: 14px; }
    #netUI { position: absolute; right: 12px; top: 12px; z-index: 50; color: white; font-size: 13px; }
    #netUI input { padding:6px; border-radius:6px; border:none; margin-right:6px; }
    #netUI button { padding:6px 10px; border-radius:6px; border:none; cursor:pointer; }
    #otherPlayersLabel { position: absolute; right: 12px; top: 70px; z-index: 50; color: white; font-size: 13px; background: rgba(0,0,0,0.35); padding:8px; border-radius:8px; }
  </style>

  <script src="https://cdn.babylonjs.com/babylon.js"></script>
  <script src="https://cdn.babylonjs.com/materialsLibrary/babylon.waterMaterial.min.js"></script>
  <script src="https://cdn.babylonjs.com/earcut.min.js"></script>
  <script src="https://cdn.babylonjs.com/cannon.js"></script>
</head>
<body>
<canvas id="renderCanvas"></canvas>

<div id="ui">
  <div id="coinCounter">Coins: <span id="coinsValue">0</span></div>
  <div id="multiplier" style="display:none;">Multiplier: <span id="multValue">2x</span> — <span id="multTime">30</span>s</div>
</div>

<div id="netUI">
  <input id="roomInput" placeholder="room id (optional)" />
  <input id="serverInput" placeholder="ws://localhost:8080" style="width:220px"/>
  <button id="connectBtn">Connect</button>
  <div id="netStatus" style="margin-top:6px;font-size:12px;opacity:0.9"></div>
</div>

<div id="otherPlayersLabel" style="display:none;">Other Players: <span id="otherCount">0</span></div>

<script>
const canvas = document.getElementById("renderCanvas");
const engine = new BABYLON.Engine(canvas, true);

const SETTINGS = {
  groundTopColor:  "#33FF4B",
  groundSideColor: "#8B5A2B",
  waterColor:      "#4DA6FF",
  waterUnderColor: "#0B3B8C",
  skyColor:        "#9DE9FF",
  cubeCount: 30,
  hillCount: 10,
  treeCount: 40,
  cubeSize: 2,
  safeRadius: 8,
  coinMax: 32,
  coinRespawnSec: 45,
  ringRadius: 5.0,
  ringThickness: 0.6,
  ringHeightOffset: 6.0,
  dayColor: "#9DE9FF",
  nightColor: "#1B2432",
  dayNightCycleMs: 5 * 60 * 1000,
  coatTexture: "box-texture.png",
  coatSize: 1.0
};

const WATER_DEPTH = 20;
const WATER_SURFACE_Y = 0;

function rndRange(min,max){ return Math.random()*(max-min)+min; }
function color3(hex){ return BABYLON.Color3.FromHexString(hex); }

function makeTriWedge(scene, name="ramp", width=10, height=6, depth=8) {
  const tri = [ new BABYLON.Vector3(0,0,0), new BABYLON.Vector3(width,0,0), new BABYLON.Vector3(0,height,0) ];
  const path = [ new BABYLON.Vector3(0,0,0), new BABYLON.Vector3(0,0,depth) ];
  const ramp = BABYLON.MeshBuilder.ExtrudeShape(name, { shape: tri, path, cap: BABYLON.Mesh.CAP_ALL }, scene);
  ramp.position.y = height / 2;
  const mat = new BABYLON.StandardMaterial(name + "Mat", scene);
  mat.diffuseColor = new BABYLON.Color3(0.65,0.65,0.65);
  ramp.material = mat;
  ramp.physicsImpostor = new BABYLON.PhysicsImpostor(ramp,BABYLON.PhysicsImpostor.MeshImpostor,{ mass:0, friction:1.0, restitution:0 },scene);
  ramp.receiveShadows = true;
  ramp.isPickable = false;
  return ramp;
}

function placeCubePyramid(scene, originX, originZ, baseCount = 5, cubeSize = 2, spacing = 2.2) {
  const meshes = [];
  let layer = 0;
  for (let n = baseCount; n >= 1; n--) {
    const layerY = (cubeSize/2) + layer * (cubeSize + 0.02);
    const rowWidth = n * spacing;
    const rowStartX = originX - (rowWidth/2) + spacing/2;
    const rowStartZ = originZ - (rowWidth/2) + spacing/2;
    for (let r = 0; r < n; r++) {
      for (let c = 0; c < n; c++) {
        const x = rowStartX + c * spacing;
        const z = rowStartZ + r * spacing;
        const box = BABYLON.MeshBuilder.CreateBox("pyr_cube_" + layer + "_" + r + "_" + c, { size: cubeSize }, scene);
        box.position.set(x, layerY, z);
        const m = new BABYLON.StandardMaterial("pyrMat_" + layer + "_" + r + "_" + c, scene);
        if (SETTINGS.coatTexture) {
          const tex = new BABYLON.Texture(SETTINGS.coatTexture, scene);
          tex.uScale = SETTINGS.coatSize;
          tex.vScale = SETTINGS.coatSize;
          tex.wrapU = BABYLON.Texture.CLAMP_ADDRESSMODE;
          tex.wrapV = BABYLON.Texture.CLAMP_ADDRESSMODE;
          m.diffuseTexture = tex;
        } else {
          m.diffuseColor = new BABYLON.Color3(0.8,0.7,0.6);
        }
        box.material = m;
        box.physicsImpostor = new BABYLON.PhysicsImpostor(box,BABYLON.PhysicsImpostor.BoxImpostor,{ mass: 0, friction: 1 },scene);
        meshes.push(box);
      }
    }
    layer++;
  }
  return meshes;
}

function createScene(){
  const scene = new BABYLON.Scene(engine);
  scene.enablePhysics(new BABYLON.Vector3(0,-9.81,0), new BABYLON.CannonJSPlugin());

  const hemi = new BABYLON.HemisphericLight("hemi", new BABYLON.Vector3(0,1,0), scene);
  hemi.intensity = 0.85;
  const sun = new BABYLON.DirectionalLight("sun", new BABYLON.Vector3(-0.2,-1,0.2), scene);
  sun.position = new BABYLON.Vector3(0,50,0);

  // GROUND
  const groundSize = 300;
  const groundHeight = 10;
  const groundBox = BABYLON.MeshBuilder.CreateBox("groundBox",{ width: groundSize, height: groundHeight, depth: groundSize }, scene);
  groundBox.position.y = -groundHeight/2;
  const topMat = new BABYLON.StandardMaterial("groundTopMat", scene);
  topMat.diffuseColor = color3(SETTINGS.groundTopColor);
  const sideMat = new BABYLON.StandardMaterial("groundSideMat", scene);
  sideMat.diffuseColor = color3(SETTINGS.groundSideColor);
  const groundMulti = new BABYLON.MultiMaterial("groundMulti", scene);
  groundMulti.subMaterials = [sideMat, sideMat, sideMat, sideMat, topMat, sideMat];
  groundBox.material = groundMulti;
  groundBox.physicsImpostor = new BABYLON.PhysicsImpostor(groundBox,BABYLON.PhysicsImpostor.BoxImpostor,{ mass:0, friction:1 },scene);

  // WATER
  const waterMesh = BABYLON.MeshBuilder.CreateGround("waterSurface", { width:700, height:700, subdivisions:32 }, scene);
  waterMesh.position.y = WATER_SURFACE_Y;
  const waterMat = new BABYLON.WaterMaterial("waterMat", scene, {});
  waterMat.bumpTexture = new BABYLON.Texture("https://cdn.babylonjs.com/textures/waterbump.png", scene);
  waterMat.windForce = -5;
  waterMat.waveHeight = 0.5;
  waterMat.waveLength = 0.1;
  waterMat.waterColor = color3(SETTINGS.waterColor);
  waterMat.colorBlendFactor = 0.3;
  waterMat.addToRenderList(groundBox);
  waterMesh.material = waterMat;

  const waterVol = BABYLON.MeshBuilder.CreateBox("waterVolume", { width:700, height: WATER_DEPTH, depth:700 }, scene);
  waterVol.position.y = WATER_SURFACE_Y - WATER_DEPTH/2;
  const waterVolMat = new BABYLON.StandardMaterial("waterVolMat", scene);
  waterVolMat.diffuseColor = color3(SETTINGS.waterColor);
  waterVolMat.alpha = 0.35;
  waterVolMat.backFaceCulling = false;
  waterVolMat.specularColor = new BABYLON.Color3(0,0,0);
  waterVol.material = waterVolMat;
  waterVol.isPickable = false;

  // RAMPS
  const RAMPS = [
    { x: 20,  z: 20,  rotY: 0,           width: 12, height: 6, depth: 8 },
    { x: -30, z: -10, rotY: Math.PI/2,  width: 10, height: 8, depth: 8 },
    { x: 40,  z: -40, rotY: Math.PI/3,  width: 14, height: 7, depth: 10 }
  ];
  const ramps = [];
  for (const r of RAMPS) {
    const wedge = makeTriWedge(scene, "ramp_" + r.x + "_" + r.z, r.width, r.height, r.depth);
    wedge.position.x = r.x;
    wedge.position.z = r.z;
    wedge.rotation.y = r.rotY;
    ramps.push({ mesh: wedge, def: r });
  }

  // RINGS
  const rings = [];
  for (let i = 0; i < ramps.length; i++) {
    const ramp = ramps[i].mesh;
    const pos = ramp.position.clone();
    pos.y += ramps[i].def.height + SETTINGS.ringHeightOffset;
    const tor = BABYLON.MeshBuilder.CreateTorus("ring" + i,{ diameter: SETTINGS.ringRadius*2, thickness: SETTINGS.ringThickness }, scene);
    tor.position.copyFrom(pos);
    tor.rotation.x = Math.PI/2;
    tor.rotation.y = ramp.rotation.y;
    const rm = new BABYLON.StandardMaterial("ringMat" + i, scene);
    rm.emissiveColor = new BABYLON.Color3(0.9,0.7,0.1);
    tor.material = rm;
    rings.push(tor);
  }

  // TREES
  const trees = [];
  (function placeTrees() {
    const count = SETTINGS.treeCount;
    let attempts = 0, placed = 0;
    while (placed < count && attempts < count*30) {
      attempts++;
      const x = rndRange(-groundSize/2+10, groundSize/2-10);
      const z = rndRange(-groundSize/2+10, groundSize/2-10);
      let ok = true;
      for (const r of RAMPS) if (Math.hypot(x-r.x, z-r.z)<Math.max(r.width,10)+6){ ok=false; break; }
      if(!ok) continue;
      let tooClose=false;
      for(const t of trees) if(Math.hypot(x-t.x,z-t.z)<3.5){ tooClose=true; break; }
      if(tooClose) continue;
      const trunkH = rndRange(2.2,3.6);
      const leafH = rndRange(3,5);
      const leafSize = rndRange(2,4);
      const trunk = BABYLON.MeshBuilder.CreateCylinder("trunk"+placed,{height:trunkH,diameterTop:0.5,diameterBottom:0.8},scene);
      trunk.position.set(x,trunkH/2,z);
      trunk.material = new BABYLON.StandardMaterial("tm"+placed,scene);
      trunk.material.diffuseColor = new BABYLON.Color3(0.35,0.25,0.12);
      const leaf = BABYLON.MeshBuilder.CreateCylinder("leaf"+placed,{height:leafH,diameterBottom:leafSize,diameterTop:0},scene);
      leaf.position.set(x,trunkH+leafH/2-0.3,z);
      leaf.material = new BABYLON.StandardMaterial("lm"+placed,scene);
      leaf.material.diffuseColor = color3(SETTINGS.groundTopColor);
      trees.push({trunk,leaf,x,z});
      placed++;
    }
  })();

  // COINS
  const coins = [];
  const coinMat = new BABYLON.StandardMaterial("coinMat", scene);
  coinMat.emissiveColor = new BABYLON.Color3(1,0.85,0.1);
  function spawnCoin(id){
    const c = BABYLON.MeshBuilder.CreateTorus("coin"+id,{diameter:1,thickness:0.2},scene);
    c.rotation.x = Math.PI/2;
    c.material = coinMat;
    c.position.set(rndRange(-groundSize/2+12,groundSize/2-12),1.2,rndRange(-groundSize/2+12,groundSize/2-12));
    return c;
  }
  for(let i=0;i<SETTINGS.coinMax;i++) coins.push({id:i,mesh:spawnCoin(i),active:true});

  /* ---------------- PLAYER SPHERE ---------------- */
  const player = BABYLON.MeshBuilder.CreateSphere("player",{diameter:2},scene);
  player.position.y = 5;
  const playerMat = new BABYLON.StandardMaterial("playerMat", scene);
  playerMat.diffuseColor = new BABYLON.Color3(0.2,0.8,1);
  player.material = playerMat;

  player.physicsImpostor = new BABYLON.PhysicsImpostor(player,BABYLON.PhysicsImpostor.SphereImpostor,{ mass:1, friction:0.8, restitution:0.2 },scene);

  /* ---------------- 3RD PERSON FOLLOW CAMERA ---------------- */
  const followCam = new BABYLON.UniversalCamera("followCam", new BABYLON.Vector3(0,10,-20), scene);
  followCam.lockedTarget = player;
  followCam.minZ = 0.1;
  followCam.position = player.position.add(new BABYLON.Vector3(0,10,-20));

  scene.registerBeforeRender(()=>{
    // smooth follow
    const targetPos = player.position.add(new BABYLON.Vector3(0,6,-15));
    followCam.position = BABYLON.Vector3.Lerp(followCam.position,targetPos,0.1);
    followCam.setTarget(player.position.add(new BABYLON.Vector3(0,3,0)));
  });

  /* ---------------- PLAYER CONTROLS (WASD + space jump) ---------------- */
  const inputMap = {};
  scene.actionManager = new BABYLON.ActionManager(scene);
  scene.actionManager.registerAction(new BABYLON.ExecuteCodeAction(BABYLON.ActionManager.OnKeyDownTrigger,(evt)=>{ inputMap[evt.sourceEvent.key.toLowerCase()] = true; }));
  scene.actionManager.registerAction(new BABYLON.ExecuteCodeAction(BABYLON.ActionManager.OnKeyUpTrigger,(evt)=>{ inputMap[evt.sourceEvent.key.toLowerCase()] = false; }));

  const moveSpeed = 0.25;
  const jumpForce = 5;
  scene.onBeforeRenderObservable.add(()=>{
    const v = player.physicsImpostor.getLinearVelocity() || new BABYLON.Vector3.Zero();
    let moveDir = new BABYLON.Vector3.Zero();
    if(inputMap["w"]) moveDir.z += 1;
    if(inputMap["s"]) moveDir.z -= 1;
    if(inputMap["a"]) moveDir.x -= 1;
    if(inputMap["d"]) moveDir.x += 1;
    moveDir = moveDir.normalize().scale(moveSpeed);
    const newVel = new BABYLON.Vector3(moveDir.x, v.y, moveDir.z);
    player.physicsImpostor.setLinearVelocity(newVel);
    if(inputMap[" "]){ // jump
      const ray = new BABYLON.Ray(player.position, new BABYLON.Vector3(0,-1,0), 1.1);
      const pick = scene.pickWithRay(ray);
      if(pick.hit) player.physicsImpostor.applyImpulse(new BABYLON.Vector3(0,jumpForce,0), player.getAbsolutePosition());
    }
  });

  /* ---------------- DAY/NIGHT + UNDERWATER ---------------- */
  scene.registerBeforeRender(()=>{
    const t = (Date.now() % SETTINGS.dayNightCycleMs) / SETTINGS.dayNightCycleMs;
    const mix = Math.sin(t*Math.PI*2)*0.5+0.5;
    const dayNightColor = BABYLON.Color3.Lerp(color3(SETTINGS.nightColor),color3(SETTINGS.dayColor),mix);
    const camY = player.position.y;
    const underwater = camY<WATER_SURFACE_Y;
    if(underwater){
      scene.clearColor = color3(SETTINGS.waterUnderColor);
      scene.fogMode = BABYLON.Scene.FOGMODE_EXP2;
      scene.fogDensity = 0.02;
      scene.fogColor = color3(SETTINGS.waterUnderColor);
      waterMat.waterColor = color3(SETTINGS.waterUnderColor);
      waterVolMat.diffuseColor = color3(SETTINGS.waterUnderColor);
      waterVolMat.alpha = 0.45;
    } else {
      scene.clearColor = dayNightColor;
      scene.fogMode = BABYLON.Scene.FOGMODE_NONE;
      waterMat.waterColor = color3(SETTINGS.waterColor);
      waterVolMat.diffuseColor = color3(SETTINGS.waterColor);
      waterVolMat.alpha = 0.35;
    }
    const now = performance.now()*0.001;
    waterMat.bumpTexture.uOffset = Math.sin(now*0.3)*0.02;
    waterMat.bumpTexture.vOffset = Math.cos(now*0.27)*0.02;
  });

  return scene;
}

const scene = createScene();
engine.runRenderLoop(()=> scene.render());
window.addEventListener("resize",()=>engine.resize());
</script>
</body>
</html>
