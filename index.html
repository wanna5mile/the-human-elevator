<!DOCTYPE html>
<html>
<head>
    <meta charset="utf-8">
    <title>Babylon Player Demo</title>
    <style>
        html, body { width: 100%; height: 100%; margin: 0; overflow: hidden; }
        #renderCanvas { width: 100%; height: 100%; touch-action: none; }
    </style>

    <script src="https://cdn.babylonjs.com/babylon.js"></script>
    <script src="https://cdn.babylonjs.com/cannon.js"></script>
</head>
<body>
<canvas id="renderCanvas"></canvas>

<script>
const canvas = document.getElementById("renderCanvas");
const engine = new BABYLON.Engine(canvas, true);

const createScene = function () {
    const scene = new BABYLON.Scene(engine);
    scene.clearColor = new BABYLON.Color3(0.62, 0.91, 1); // 9DE9FF

    // ⭐ Add lighting
    const light = new BABYLON.HemisphericLight("hemi", new BABYLON.Vector3(0, 1, 0), scene);
    light.intensity = 1.2;

    // Physics
    const gravityVector = new BABYLON.Vector3(0, -9.81, 0);
    scene.enablePhysics(gravityVector, new BABYLON.CannonJSPlugin());

    // Ground
    const ground = BABYLON.MeshBuilder.CreateGround("ground", {
        width: 200,
        height: 200
    }, scene);
    ground.material = new BABYLON.StandardMaterial("gmat", scene);
    ground.material.diffuseColor = BABYLON.Color3.FromHexString("#33F4B");
    ground.physicsImpostor = new BABYLON.PhysicsImpostor(
        ground, BABYLON.PhysicsImpostor.BoxImpostor,
        { mass: 0, friction: 1, restitution: 0 }, scene
    );

    // Player Sphere
    const sphere = BABYLON.MeshBuilder.CreateSphere("player", { diameter: 2 }, scene);
    sphere.position = new BABYLON.Vector3(0, 3, 0);
    sphere.material = new BABYLON.StandardMaterial("smat", scene);
    sphere.material.diffuseColor = BABYLON.Color3.Random();

    sphere.physicsImpostor = new BABYLON.PhysicsImpostor(
        sphere, BABYLON.PhysicsImpostor.SphereImpostor,
        { mass: 1, friction: 0.5, restitution: 0 }, scene
    );

    // ⭐ Real Third-Person Camera (no rotation)
    const camera = new BABYLON.ArcRotateCamera(
        "cam",
        BABYLON.Tools.ToRadians(0),   // alpha (left-right orbit)
        BABYLON.Tools.ToRadians(60),  // beta (up-down angle)
        20,                           // radius distance
        sphere.position.clone(),      // target position
        scene
    );
    camera.attachControl(canvas, true);
    camera.lowerBetaLimit = BABYLON.Tools.ToRadians(10);
    camera.upperBetaLimit = BABYLON.Tools.ToRadians(80);

    // Movement controls
    const input = { w: false, a: false, s: false, d: false, space: false };
    window.addEventListener("keydown", (e) => input[e.key.toLowerCase()] = true);
    window.addEventListener("keyup",   (e) => input[e.key.toLowerCase()] = false);

    let canJump = false;
    const MOVE_SPEED = 1.2;
    const DAMPING = 0.92;

    // Update loop
    scene.registerBeforeRender(() => {

        // ⭐ Camera follows sphere POSITION only
        const targetPos = sphere.position.clone();
        camera.target = BABYLON.Vector3.Lerp(camera.target, targetPos, 0.1);

        // Movement physics
        const vel = sphere.physicsImpostor.getLinearVelocity();

        vel.x *= DAMPING;
        vel.z *= DAMPING;

        if (input.w) vel.z -= MOVE_SPEED;
        if (input.s) vel.z += MOVE_SPEED;
        if (input.a) vel.x -= MOVE_SPEED;
        if (input.d) vel.x += MOVE_SPEED;

        if (input.space && canJump) {
            vel.y = 8;
            canJump = false;
        }

        sphere.physicsImpostor.setLinearVelocity(vel);

        // Ground check
        if (Math.abs(sphere.position.y - 1) < 0.3) {
            canJump = true;
        }

        // Respawn
        if (sphere.position.y < -20) {
            sphere.physicsImpostor.setLinearVelocity(BABYLON.Vector3.Zero());
            sphere.position = new BABYLON.Vector3(0, 5, 0);
        }
    });

    // Cube spawner
    function spawnCube() {
        const cube = BABYLON.MeshBuilder.CreateBox("cube", { size: 2 }, scene);
        cube.material = new BABYLON.StandardMaterial("cmat", scene);
        cube.material.diffuseColor = BABYLON.Color3.Random();

        const DIST = 15;
        let x, z;
        do {
            x = (Math.random() - 0.5) * 180;
            z = (Math.random() - 0.5) * 180;
        } while (Math.abs(x - sphere.position.x) < DIST &&
                 Math.abs(z - sphere.position.z) < DIST);

        cube.position = new BABYLON.Vector3(x, 5, z);

        cube.physicsImpostor = new BABYLON.PhysicsImpostor(
            cube, BABYLON.PhysicsImpostor.BoxImpostor,
            { mass: 1, friction: 0.8, restitution: 0.2 }, scene
        );

        // Respawn cubes
        scene.registerBeforeRender(() => {
            if (cube.position.y < -20) {
                cube.position = new BABYLON.Vector3(x, 10, z);
                cube.physicsImpostor.setLinearVelocity(BABYLON.Vector3.Zero());
            }
        });
    }

    for (let i = 0; i < 30; i++) spawnCube();

    return scene;
};

const scene = createScene();
engine.runRenderLoop(() => scene.render());
</script>

</body>
</html>
