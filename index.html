<!DOCTYPE html>
<html>
<head>
    <meta charset="utf-8">
    <title>Babylon Player Demo</title>
    <style>
        html, body { width: 100%; height: 100%; margin: 0; overflow: hidden; }
        #renderCanvas { width: 100%; height: 100%; touch-action: none; }
    </style>
    <script src="https://cdn.babylonjs.com/babylon.js"></script>
</head>
<body>
<canvas id="renderCanvas"></canvas>

<script>
const canvas = document.getElementById("renderCanvas");
const engine = new BABYLON.Engine(canvas, true);

const createScene = () => {
    const scene = new BABYLON.Scene(engine);

    // ----- CAMERA -----
    const camera = new BABYLON.ArcRotateCamera("camera",
        Math.PI / 2, Math.PI / 3, 25,
        new BABYLON.Vector3(0, 2, 0),
        scene
    );
    camera.attachControl(canvas, true);

    // Arrow keys rotate camera
    const cameraRotationSpeed = 0.03;
    window.addEventListener("keydown", (e) => {
        if (e.key === "ArrowLeft")  camera.alpha -= cameraRotationSpeed;
        if (e.key === "ArrowRight") camera.alpha += cameraRotationSpeed;
        if (e.key === "ArrowUp")    camera.beta -= cameraRotationSpeed;
        if (e.key === "ArrowDown")  camera.beta += cameraRotationSpeed;
    });

    // ----- LIGHT -----
    new BABYLON.HemisphericLight("light", new BABYLON.Vector3(1, 1, 0), scene);

    // ----- SKY COLOR -----
    scene.clearColor = BABYLON.Color3.FromHexString("#9DE9FF");

    // ----- GROUND -----
    const ground = BABYLON.MeshBuilder.CreateGround("ground", { width: 200, height: 200 }, scene);
    const groundMat = new BABYLON.StandardMaterial("groundMat", scene);
    groundMat.diffuseColor = BABYLON.Color3.FromHexString("#33FF4B");
    ground.material = groundMat;
    ground.checkCollisions = true;

    // ----- ENABLE PHYSICS -----
    const gravityVector = new BABYLON.Vector3(0, -9.81, 0);
    const physicsPlugin = new BABYLON.CannonJSPlugin();
    scene.enablePhysics(gravityVector, physicsPlugin);

    // ----- PLAYER SPHERE -----
    const sphere = BABYLON.MeshBuilder.CreateSphere("player", { diameter: 2 }, scene);
    sphere.position.y = 5;

    const randomColor = () => new BABYLON.Color3(Math.random(), Math.random(), Math.random());
    const sphereMat = new BABYLON.StandardMaterial("sphereMat", scene);
    sphereMat.diffuseColor = randomColor();
    sphere.material = sphereMat;

    sphere.physicsImpostor = new BABYLON.PhysicsImpostor(
        sphere, BABYLON.PhysicsImpostor.SphereImpostor, { mass: 1, friction: 0.5, restitution: 0.2 }
    );

    // ----- PLAYER MOVEMENT -----
    const input = { w: false, a: false, s: false, d: false };
    const speed = 0.2;
    let canJump = true;

    window.addEventListener("keydown", (e) => {
        if (e.key.toLowerCase() in input) input[e.key.toLowerCase()] = true;

        if (e.key === " " && canJump) {
            sphere.physicsImpostor.setLinearVelocity(new BABYLON.Vector3(0, 6, 0));
            canJump = false;
        }
    });

    window.addEventListener("keyup", (e) => {
        if (e.key.toLowerCase() in input) input[e.key.toLowerCase()] = false;
    });

    scene.onBeforeRenderObservable.add(() => {
        const vel = sphere.physicsImpostor.getLinearVelocity();
        let moveX = 0;
        let moveZ = 0;

        if (input.w) moveZ += speed;
        if (input.s) moveZ -= speed;
        if (input.a) moveX -= speed;
        if (input.d) moveX += speed;

        sphere.physicsImpostor.setLinearVelocity(
            new BABYLON.Vector3(vel.x + moveX, vel.y, vel.z + moveZ)
        );

        // Check for respawn
        if (sphere.position.y < -20) {
            sphere.position.set(0, 10, 0);
            sphere.physicsImpostor.setLinearVelocity(new BABYLON.Vector3(0, 0, 0));
        }
    });

    // Detect landing (reset jump)
    sphere.physicsImpostor.registerOnPhysicsCollide(ground.physicsImpostor, () => {
        canJump = true;
    });

    // ----- RANDOM CUBES -----
    function spawnCube() {
        const safeRadius = 5; // avoid player
        let x, z;

        do {
            x = (Math.random() - 0.5) * 150;
            z = (Math.random() - 0.5) * 150;
        } while (Math.sqrt(x * x + z * z) < safeRadius);

        const cube = BABYLON.MeshBuilder.CreateBox("cube", { size: 2 }, scene);
        cube.position = new BABYLON.Vector3(x, 10, z);

        const mat = new BABYLON.StandardMaterial("cubeMat", scene);
        mat.diffuseColor = randomColor();
        cube.material = mat;

        cube.physicsImpostor = new BABYLON.PhysicsImpostor(
            cube, BABYLON.PhysicsImpostor.BoxImpostor, { mass: 1, friction: 1, restitution: 0.1 }
        );
    }

    // Spawn a bunch of cubes
    for (let i = 0; i < 25; i++) spawnCube();

    return scene;
};

const scene = createScene();
engine.runRenderLoop(() => scene.render());

// Resize if window changes size
window.addEventListener("resize", () => engine.resize());
</script>
</body>
</html>
