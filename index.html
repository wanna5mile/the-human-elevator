<!DOCTYPE html>
<html>
<head>
<meta charset="utf-8" />
<title>Babylon — Camera-Aligned Movement</title>
<style>
  html,body { width:100%; height:100%; margin:0; overflow:hidden; }
  #renderCanvas { width:100%; height:100%; touch-action:none; display:block; }
  #angleDisplay {
    position: absolute;
    top: 10px; right: 10px;
    color: white;
    font-family: monospace;
    background: rgba(0,0,0,0.5);
    padding: 6px 12px;
    border-radius: 6px;
  }
</style>
<script src="https://cdn.babylonjs.com/babylon.js"></script>
<script src="https://cdn.babylonjs.com/cannon.js"></script>
</head>
<body>
<canvas id="renderCanvas"></canvas>
<div id="angleDisplay">Angle: 0°</div>

<script>
const canvas = document.getElementById("renderCanvas");
const engine = new BABYLON.Engine(canvas,true);

const SETTINGS = {
  groundColor: "#33FF4B",
  skyColor: "#9DE9FF",
  moveForce: 8,
  maxSpeed: 8,
  jumpForce: 6,
  damp: 0.9,
  respawnY: -20
};

/* ---------------- SCENE ---------------- */
function createScene() {
  const scene = new BABYLON.Scene(engine);
  scene.clearColor = BABYLON.Color3.FromHexString(SETTINGS.skyColor);
  scene.enablePhysics(new BABYLON.Vector3(0,-9.81,0), new BABYLON.CannonJSPlugin());

  new BABYLON.HemisphericLight("hemi", new BABYLON.Vector3(0,1,0), scene);

  // Ground
  const ground = BABYLON.MeshBuilder.CreateGround("ground",{width:300,height:300},scene);
  const gMat = new BABYLON.StandardMaterial("gMat",scene);
  gMat.diffuseColor = BABYLON.Color3.FromHexString(SETTINGS.groundColor);
  ground.material = gMat;
  ground.physicsImpostor = new BABYLON.PhysicsImpostor(ground,BABYLON.PhysicsImpostor.BoxImpostor,{mass:0,friction:2,restitution:0},scene);

  // Player Sphere
  const sphere = BABYLON.MeshBuilder.CreateSphere("player",{diameter:2},scene);
  sphere.position.set(0,3,0);
  const sMat = new BABYLON.StandardMaterial("sMat",scene);
  sMat.diffuseColor = BABYLON.Color3.Random();
  sphere.material = sMat;
  sphere.physicsImpostor = new BABYLON.PhysicsImpostor(sphere,BABYLON.PhysicsImpostor.SphereImpostor,{mass:1,friction:0.6,restitution:0.05},scene);

  // Camera
  const camera = new BABYLON.ArcRotateCamera("cam",0,BABYLON.Tools.ToRadians(55),15,sphere.position,scene);
  camera.attachControl(canvas,true);
  camera.lowerRadiusLimit = 6;
  camera.upperRadiusLimit = 40;
  camera.wheelDeltaPercentage = 0.01;

  let manualCam=false, lastManual=0;
  const CAM_TIMEOUT=1500;
  window.addEventListener("keydown",e=>{
    if(e.key.startsWith("Arrow")){
      manualCam=true; lastManual=performance.now();
      if(e.key==="ArrowLeft") camera.alpha-=0.03;
      if(e.key==="ArrowRight") camera.alpha+=0.03;
      if(e.key==="ArrowUp") camera.beta=Math.max(0.2,camera.beta-0.03);
      if(e.key==="ArrowDown") camera.beta=Math.min(Math.PI-0.2,camera.beta+0.03);
    }
  });

  // Input
  const input={forward:false,back:false,left:false,right:false,jump:false};
  window.addEventListener("keydown",e=>{
    const k=e.key.toLowerCase();
    if(k==="w")input.forward=true;
    if(k==="s")input.back=true;
    if(k==="a")input.left=true;
    if(k==="d")input.right=true;
    if(e.key===" ")input.jump=true;
  });
  window.addEventListener("keyup",e=>{
    const k=e.key.toLowerCase();
    if(k==="w")input.forward=false;
    if(k==="s")input.back=false;
    if(k==="a")input.left=false;
    if(k==="d")input.right=false;
    if(e.key===" ")input.jump=false;
  });

  // Utilities
  const rayDown = new BABYLON.Vector3(0,-1,0);
  const grounded=()=>{ const r=new BABYLON.Ray(sphere.position,rayDown,1.15); const hit=scene.pickWithRay(r,m=>m!==sphere); return hit&&hit.hit; };
  const clampVel=v=>{ const h=new BABYLON.Vector3(v.x,0,v.z); const l=h.length(); if(l>SETTINGS.maxSpeed){h.scaleInPlace(SETTINGS.maxSpeed/l); return new BABYLON.Vector3(h.x,v.y,h.z);} return v; };
  let lastMove = new BABYLON.Vector3(0,0,1);

  const angleDisplay = document.getElementById("angleDisplay");

  /* ---------------- GAME LOOP ---------------- */
  scene.registerBeforeRender(()=>{
    // Expire manual camera rotation
    if(manualCam && performance.now()-lastManual>CAM_TIMEOUT) manualCam=false;

    // Camera-relative movement
    const camDir = new BABYLON.Vector3(Math.sin(camera.alpha+Math.PI),0,Math.cos(camera.alpha+Math.PI));
    const rightDir = new BABYLON.Vector3(camDir.z,0,-camDir.x);

    let moveDir = BABYLON.Vector3.Zero();
    if(input.forward) moveDir.addInPlace(camDir);
    if(input.back) moveDir.subtractInPlace(camDir);
    if(input.left) moveDir.subtractInPlace(rightDir);
    if(input.right) moveDir.addInPlace(rightDir);

    if(moveDir.lengthSquared()>0.001){
      moveDir.normalize();
      lastMove.copyFrom(moveDir);
    }

    const v = sphere.physicsImpostor.getLinearVelocity();
    const damped = new BABYLON.Vector3(v.x*SETTINGS.damp,v.y,v.z*SETTINGS.damp);
    if(moveDir.length()>0.001) sphere.physicsImpostor.setLinearVelocity(clampVel(damped.add(moveDir.scale(SETTINGS.moveForce*engine.getDeltaTime()*0.06))));
    else sphere.physicsImpostor.setLinearVelocity(new BABYLON.Vector3(damped.x,v.y,damped.z));

    if(input.jump && grounded()) sphere.physicsImpostor.setLinearVelocity(new BABYLON.Vector3(v.x,SETTINGS.jumpForce,v.z));

    if(sphere.position.y<SETTINGS.respawnY){
      sphere.position.set(0,6,0);
      sphere.physicsImpostor.setLinearVelocity(BABYLON.Vector3.Zero());
    }

    // Auto camera follow
    if(!manualCam){
      const desired = Math.atan2(lastMove.x,lastMove.z);
      camera.alpha = BABYLON.Scalar.Lerp(camera.alpha,desired,0.18);
    }
    camera.target = BABYLON.Vector3.Lerp(camera.target,sphere.position,0.28);

    // Update camera angle display
    let angleDeg = (camera.alpha*180/Math.PI)%360;
    if(angleDeg<0) angleDeg+=360;
    angleDisplay.textContent = "Angle: "+angleDeg.toFixed(0)+"°";
  });

  return scene;
}

/* ---------------- RUN ---------------- */
const scene = createScene();
engine.runRenderLoop(()=>scene.render());
window.addEventListener("resize",()=>engine.resize());
</script>
</body>
</html>
