<!DOCTYPE html>
<html>
<head>
    <meta charset="utf-8">
    <title>Babylon Player Demo</title>
    <style>
        html, body { width: 100%; height: 100%; margin: 0; overflow: hidden; }
        #renderCanvas { width: 100%; height: 100%; touch-action: none; }
    </style>

    <script src="https://cdn.babylonjs.com/babylon.js"></script>
    <script src="https://cdn.babylonjs.com/cannon.js"></script>
</head>
<body>
<canvas id="renderCanvas"></canvas>

<script>
const canvas = document.getElementById("renderCanvas");
const engine = new BABYLON.Engine(canvas, true);

const createScene = function () {
    const scene = new BABYLON.Scene(engine);
    scene.clearColor = BABYLON.Color3.FromHexString("#9DE9FF");

    // Lighting
    const light = new BABYLON.HemisphericLight("hemi", new BABYLON.Vector3(0, 1, 0), scene);
    light.intensity = 1.2;

    // Physics
    scene.enablePhysics(new BABYLON.Vector3(0, -9.81, 0), new BABYLON.CannonJSPlugin());

    // Ground
    const ground = BABYLON.MeshBuilder.CreateGround("ground", { width: 200, height: 200 }, scene);
    const groundMat = new BABYLON.StandardMaterial("gmat", scene);
    groundMat.diffuseColor = BABYLON.Color3.FromHexString("#33FF4B"); // FIXED GREEN
    ground.material = groundMat;

    ground.physicsImpostor = new BABYLON.PhysicsImpostor(
        ground, BABYLON.PhysicsImpostor.BoxImpostor,
        { mass: 0, friction: 1, restitution: 0 }
    );

    // Player Sphere
    const sphere = BABYLON.MeshBuilder.CreateSphere("player", { diameter: 2 }, scene);
    sphere.position.set(0, 3, 0);
    sphere.material = new BABYLON.StandardMaterial("smat", scene);
    sphere.material.diffuseColor = BABYLON.Color3.Random();

    sphere.physicsImpostor = new BABYLON.PhysicsImpostor(
        sphere, BABYLON.PhysicsImpostor.SphereImpostor,
        { mass: 1, friction: 0.5, restitution: 0 }
    );

    // ⭐ True 3rd-person Arc Camera
    const camera = new BABYLON.ArcRotateCamera(
        "cam",
        BABYLON.Tools.ToRadians(0),
        BABYLON.Tools.ToRadians(60),
        20,
        sphere.position.clone(),
        scene
    );
    camera.attachControl(canvas, true);
    camera.lowerBetaLimit = BABYLON.Tools.ToRadians(15);
    camera.upperBetaLimit = BABYLON.Tools.ToRadians(80);

    // Input
    const input = { w: false, a: false, s: false, d: false, space: false };
    window.addEventListener("keydown", e => input[e.key.toLowerCase()] = true);
    window.addEventListener("keyup", e => input[e.key.toLowerCase()] = false);

    let canJump = false;
    const SPEED = 1.2;
    const DAMPING = 0.93;

    // ⭐ Movement + Camera Follow
    scene.onBeforeRenderObservable.add(() => {

        let vel = sphere.physicsImpostor.getLinearVelocity();

        // Slowdown
        vel.x *= DAMPING;
        vel.z *= DAMPING;

        // ⭐ FIXED W/S (correct forward/backward)
        if (input.w) vel.z -= SPEED;
        if (input.s) vel.z += SPEED;

        if (input.a) vel.x -= SPEED;
        if (input.d) vel.x += SPEED;

        if (input.space && canJump) {
            vel.y = 8;
            canJump = false;
        }

        sphere.physicsImpostor.setLinearVelocity(vel);

        // Grounded check
        if (Math.abs(sphere.position.y - 1) < 0.3) canJump = true;

        // Respawn
        if (sphere.position.y < -20) {
            sphere.physicsImpostor.setLinearVelocity(BABYLON.Vector3.Zero());
            sphere.position.set(0, 5, 0);
        }

        // ⭐ REAL 3RD PERSON CAMERA BEHAVIOR
        const moveDir = new BABYLON.Vector3(vel.x, 0, vel.z);

        if (moveDir.length() > 0.05) {
            moveDir.normalize();
            let desiredAlpha = Math.atan2(moveDir.x, moveDir.z);
            camera.alpha = BABYLON.Scalar.Lerp(camera.alpha, desiredAlpha, 0.05);
        }

        camera.target = BABYLON.Vector3.Lerp(
            camera.target,
            sphere.position,
            0.1
        );
    });

    // ⭐ Ramps
    function addRamp(x, z, rotY = 0) {
        const ramp = BABYLON.MeshBuilder.CreateBox("ramp", {
            width: 10,
            depth: 10,
            height: 2
        }, scene);

        ramp.material = new BABYLON.StandardMaterial("rmat", scene);
        ramp.material.diffuseColor = BABYLON.Color3.FromInts(
            100 + Math.random()*155,
            100 + Math.random()*155,
            100 + Math.random()*155
        );

        ramp.rotation.x = Math.PI / 6; // angled ramp
        ramp.rotation.y = rotY;
        ramp.position.set(x, 1, z);

        ramp.physicsImpostor = new BABYLON.PhysicsImpostor(
            ramp, BABYLON.PhysicsImpostor.BoxImpostor,
            { mass: 0, friction: 1, restitution: 0 }
        );
    }

    addRamp(20, 20);
    addRamp(-30, -10, Math.PI / 2);
    addRamp(40, -40, Math.PI / 3);

    return scene;
};

const scene = createScene();
engine.runRenderLoop(() => scene.render());
</script>

</body>
</html>
