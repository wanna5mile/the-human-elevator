<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8" />
  <title>Babylon â€” 3rd Person Sphere</title>
  <style>
    html,body { width:100%; height:100%; margin:0; overflow:hidden; }
    #renderCanvas { width:100%; height:100%; touch-action:none; display:block; }
  </style>

  <script src="https://cdn.babylonjs.com/babylon.js"></script>
  <script src="https://cdn.babylonjs.com/cannon.js"></script>
</head>
<body>
<canvas id="renderCanvas"></canvas>

<script>
const canvas = document.getElementById("renderCanvas");
const engine = new BABYLON.Engine(canvas, true);

/* ---------------- SETTINGS ---------------- */
const GROUND_COLOR = "#33FF4B";
const SKY_COLOR    = "#9DE9FF";
const CUBE_COUNT   = 30;
const RESPAWN_Y    = -20;

const RAMP_DEFS = [
  { x: 20, z: 20, rotY: 0, angle: Math.PI/6 },
  { x: -30, z: -10, rotY: Math.PI/2, angle: Math.PI/6 },
  { x: 40, z: -40, rotY: Math.PI/3, angle: Math.PI/6 }
];

/* ---------------- CREATE SCENE ---------------- */
const createScene = () => {
  const scene = new BABYLON.Scene(engine);
  scene.clearColor = BABYLON.Color3.FromHexString(SKY_COLOR);

  // Lighting
  new BABYLON.HemisphericLight("hemi", new BABYLON.Vector3(0,1,0), scene);

  // Physics
  scene.enablePhysics(new BABYLON.Vector3(0, -9.81, 0), new BABYLON.CannonJSPlugin());

  /* --------- Ground --------- */
  const ground = BABYLON.MeshBuilder.CreateGround("ground", {
    width: 300, height: 300
  }, scene);

  const gmat = new BABYLON.StandardMaterial("gmat", scene);
  gmat.diffuseColor = BABYLON.Color3.FromHexString(GROUND_COLOR);
  ground.material = gmat;

  ground.physicsImpostor = new BABYLON.PhysicsImpostor(
    ground, BABYLON.PhysicsImpostor.BoxImpostor,
    { mass: 0, friction: 2, restitution: 0 }, scene
  );

  /* --------- Player Sphere --------- */
  const sphere = BABYLON.MeshBuilder.CreateSphere("player", { diameter: 2 }, scene);
  sphere.position.set(0,3,0);

  const sm = new BABYLON.StandardMaterial("sm", scene);
  sm.diffuseColor = BABYLON.Color3.Random();
  sphere.material = sm;

  sphere.physicsImpostor = new BABYLON.PhysicsImpostor(
    sphere, BABYLON.PhysicsImpostor.SphereImpostor,
    { mass: 1, friction: 0.6, restitution: 0.05 }, scene
  );

  /* --------- Ramps --------- */
  function addRamp(d) {
    const ramp = BABYLON.MeshBuilder.CreateBox("ramp", {
      width: 12, depth: 8, height: 2
    }, scene);

    let m = new BABYLON.StandardMaterial("rmat", scene);
    m.diffuseColor = BABYLON.Color3.Random();
    ramp.material = m;

    ramp.position.set(d.x, 1, d.z);
    ramp.rotation.x = -d.angle;
    ramp.rotation.y = d.rotY;

    ramp.physicsImpostor = new BABYLON.PhysicsImpostor(
      ramp, BABYLON.PhysicsImpostor.BoxImpostor,
      { mass: 0, friction: 1, restitution: 0 }, scene
    );
  }
  RAMP_DEFS.forEach(addRamp);

  /* --------- Cubes --------- */
  const cubes = [];
  const SAFE_RADIUS = 8;

  function spawnCube(x,z,y=8){
    const c = BABYLON.MeshBuilder.CreateBox("cube",{size:2},scene);
// Textured cube material (fills 100% of each face)
const cm = new BABYLON.StandardMaterial("cubeMat", scene);
cm.diffuseTexture = new BABYLON.Texture("box-texture.png", scene);
cm.diffuseTexture.hasAlpha = true;       // allow transparency
cm.useAlphaFromDiffuseTexture = true;    // keeps your overlay transparent
cm.specularColor = BABYLON.Color3.Black(); // no shiny reflections
cm.backFaceCulling = false;              // render both sides cleanly
c.material = cm;

    c.position.set(x,y,z);

    c.physicsImpostor = new BABYLON.PhysicsImpostor(
      c, BABYLON.PhysicsImpostor.BoxImpostor,
      { mass: 1, friction: 1, restitution: 0.05 }, scene
    );

    cubes.push({mesh:c, spawnX:x, spawnY:y, spawnZ:z});
  }

  for (let i=0; i<CUBE_COUNT; i++) {
    let x,z;
    do {
      x = (Math.random()-0.5) * 260;
      z = (Math.random()-0.5) * 260;
    } while (Math.hypot(x, z) < SAFE_RADIUS);

    spawnCube(x,z, 8 + Math.random()*12);
  }

  /* --------- Camera --------- */
  const camera = new BABYLON.ArcRotateCamera(
    "cam",
    0,
    BABYLON.Tools.ToRadians(55),
    18,
    sphere.position.clone(),
    scene
  );

  camera.attachControl(canvas, true);
  camera.lowerRadiusLimit = 6;
  camera.upperRadiusLimit = 40;
  camera.wheelDeltaPercentage = 0.01;

  /* --------- Input --------- */
  const input = { forward:false, back:false, left:false, right:false, jump:false };

  window.addEventListener("keydown", e=>{
    const k = e.key.toLowerCase();
    if (k==="w") input.forward = true;
    if (k==="s") input.back    = true;
    if (k==="a") input.left    = true;
    if (k==="d") input.right   = true;
    if (e.key===" ") input.jump = true;
  });

  window.addEventListener("keyup", e=>{
    const k = e.key.toLowerCase();
    if (k==="w") input.forward = false;
    if (k==="s") input.back    = false;
    if (k==="a") input.left    = false;
    if (k==="d") input.right   = false;
    if (e.key===" ") input.jump = false;
  });

  /* --------- Arrow Key Camera Rotation --------- */
  let manualCamera = false;
  let lastManual = 0;
  const MANUAL_TIMEOUT = 1500;
  const ROT_SPEED = 0.03;

  window.addEventListener("keydown", e=>{
    if(e.key==="ArrowLeft"){
      camera.alpha -= ROT_SPEED;
      manualCamera = true;
      lastManual = performance.now();
    }
    if(e.key==="ArrowRight"){
      camera.alpha += ROT_SPEED;
      manualCamera = true;
      lastManual = performance.now();
    }
    if(e.key==="ArrowUp"){
      camera.beta = Math.max(0.2, camera.beta - ROT_SPEED);
      manualCamera = true;
      lastManual = performance.now();
    }
    if(e.key==="ArrowDown"){
      camera.beta = Math.min(Math.PI-0.2, camera.beta + ROT_SPEED);
      manualCamera = true;
      lastManual = performance.now();
    }
  });

  /* --------- Movement Physics --------- */
  const MOVE_FORCE = 7.5;
  const MAX_SPEED  = 8.0;
  const DAMP       = 0.92;
  const JUMP_FORCE = 6.2;

  let lastMoveDir = new BABYLON.Vector3(0,0,1);

  function clampVel(v){
    const h = new BABYLON.Vector3(v.x,0,v.z);
    const l = h.length();
    if(l > MAX_SPEED){
      h.scaleInPlace(MAX_SPEED/l);
      return new BABYLON.Vector3(h.x, v.y, h.z);
    }
    return v;
  }

  function grounded() {
    const ray = new BABYLON.Ray(sphere.position.clone(), new BABYLON.Vector3(0,-1,0), 1.15);
    const pick = scene.pickWithRay(ray, m => m !== sphere);
    return pick && pick.hit;
  }

  /* ---------------- GAME LOOP ---------------- */
  scene.registerBeforeRender(()=>{

    // Expire manual camera rotation
    if(manualCamera && performance.now() - lastManual > MANUAL_TIMEOUT){
      manualCamera = false;
    }

    /* ---- Corrected camera-relative movement ---- */
    const camAlpha = camera.alpha;

    // Forward now points where camera is facing
    const forward = new BABYLON.Vector3(
      Math.sin(camAlpha + Math.PI),
      0,
      Math.cos(camAlpha + Math.PI)
    );

    const right = new BABYLON.Vector3(
      forward.z,
      0,
      -forward.x
    );

    let dir = new BABYLON.Vector3(0,0,0);
    if (input.forward) dir.addInPlace(forward);
    if (input.back)    dir.subtractInPlace(forward);
    if (input.left)    dir.subtractInPlace(right);
    if (input.right)   dir.addInPlace(right);

    if (dir.lengthSquared() > 0.001) {
      dir.normalize();
      lastMoveDir = dir.clone();
    }

    const v = sphere.physicsImpostor.getLinearVelocity();
    const damped = new BABYLON.Vector3(v.x*DAMP, v.y, v.z*DAMP);

    // Apply movement
    if (dir.length() > 0.001) {
      const desired = damped.add(dir.scale(MOVE_FORCE * engine.getDeltaTime()*0.06));
      sphere.physicsImpostor.setLinearVelocity(clampVel(desired));
    } else {
      sphere.physicsImpostor.setLinearVelocity(
        new BABYLON.Vector3(damped.x, v.y, damped.z)
      );
    }

    // Jump
    if (input.jump && grounded()) {
      sphere.physicsImpostor.setLinearVelocity(new BABYLON.Vector3(v.x, JUMP_FORCE, v.z));
    }

    // Respawn sphere
    if (sphere.position.y < RESPAWN_Y) {
      sphere.position.set(0,6,0);
      sphere.physicsImpostor.setLinearVelocity(BABYLON.Vector3.Zero());
    }

    // Respawn cubes
    for (const c of cubes) {
      if (c.mesh.position.y < RESPAWN_Y) {
        c.mesh.position.set(c.spawnX, c.spawnY, c.spawnZ);
        c.mesh.physicsImpostor.setLinearVelocity(BABYLON.Vector3.Zero());
        c.mesh.physicsImpostor.setAngularVelocity(BABYLON.Vector3.Zero());
      }
    }

    /* ---- Faster, smoother camera auto-rotate ---- */
    if (!manualCamera && lastMoveDir.length() > 0.001) {
      const desired = Math.atan2(lastMoveDir.x, lastMoveDir.z);
      camera.alpha = BABYLON.Scalar.Lerp(camera.alpha, desired, 0.18);
    }

    /* ---- Tighter camera follow ---- */
    camera.target = BABYLON.Vector3.Lerp(camera.target, sphere.position, 0.28);

  }); // END LOOP

  return scene;
};

/* ---------------- RUN SCENE ---------------- */
const scene = createScene();
engine.runRenderLoop(() => scene.render());
window.addEventListener("resize", () => engine.resize());
</script>
</body>
</html>
