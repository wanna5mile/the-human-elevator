<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8" />
  <title>Babylon — 3rd Person Sphere (With Rings, Counter & Multiplayer)</title>
  <link rel="icon" href="awodas.png" type="image/png">
  <style>
    html,body { width:100%; height:100%; margin:0; overflow:hidden; font-family: Inter, system-ui, sans-serif; }
    #renderCanvas { width:100%; height:100%; touch-action:none; display:block; }
    /* UI overlay */
    #ui {
      position: absolute;
      left: 12px;
      top: 12px;
      z-index: 50;
      color: white;
      text-shadow: 0 2px 6px rgba(0,0,0,0.7);
      user-select: none;
    }
    #coinCounter {
      background: rgba(0,0,0,0.45);
      padding: 10px 14px;
      border-radius: 8px;
      font-size: 18px;
      min-width: 120px;
    }
    #multiplier {
      margin-top: 8px;
      background: rgba(0,0,0,0.35);
      padding: 8px 12px;
      border-radius: 8px;
      font-size: 14px;
    }
    /* networking controls */
    #netUI {
      position: absolute;
      right: 12px;
      top: 12px;
      z-index: 50;
      color: white;
      font-size: 13px;
    }
    #netUI input { padding:6px; border-radius:6px; border:none; margin-right:6px; }
    #netUI button { padding:6px 10px; border-radius:6px; border:none; cursor:pointer; }
    #otherPlayersLabel {
      position: absolute;
      right: 12px;
      top: 70px;
      z-index: 50;
      color: white;
      font-size: 13px;
      background: rgba(0,0,0,0.35);
      padding:8px;
      border-radius:8px;
    }
  </style>

  <!-- Babylon -->
  <script src="https://cdn.babylonjs.com/babylon.js"></script>
  <!-- Water Material -->
  <script src="https://cdn.babylonjs.com/materialsLibrary/babylon.waterMaterial.min.js"></script>
  <!-- Earcut -->
  <script src="https://cdn.babylonjs.com/earcut.min.js"></script>
  <!-- Physics (Cannon) -->
  <script src="https://cdn.babylonjs.com/cannon.js"></script>
</head>
<body>
<canvas id="renderCanvas"></canvas>

<div id="ui">
  <div id="coinCounter">Coins: <span id="coinsValue">0</span></div>
  <div id="multiplier" style="display:none;">Multiplier: <span id="multValue">2x</span> — <span id="multTime">30</span>s</div>
</div>

<div id="netUI">
  <input id="roomInput" placeholder="room id (optional)" />
  <input id="serverInput" placeholder="ws://signaling.server:port" style="width:220px"/>
  <button id="connectBtn">Connect</button>
  <div id="netStatus" style="margin-top:6px;font-size:12px;opacity:0.9"></div>
</div>

<div id="otherPlayersLabel" style="display:none;">Other Players: <span id="otherCount">0</span></div>

<script>
/* ============================================================
   INIT + SETTINGS
============================================================ */
const canvas = document.getElementById("renderCanvas");
const engine = new BABYLON.Engine(canvas, true);

const SETTINGS = {
  groundTopColor:  "#33FF4B",
  groundSideColor: "#8B5A2B",
  waterColor:      "#4DA6FF",
  skyColor:        "#9DE9FF",

  cubeCount: 30,
  hillCount: 10,
  respawnY: -60,

  moveForce: 7.5,
  maxSpeed:  8,
  jumpForce: 6.6,
  damp: 0.92,

  coatTexture: "box-texture.png",
  coatSize:    2.04,
  cubeSize:    2,
  safeRadius:  8,

  swimUpSpeed: 4,
  coinMax: 32,
  coinRespawnSec: 45,

  ringRadius: 5.0,
  ringThickness: 0.6,
  ringHeightOffset: 6.0,       // how high above ramp center the ring sits
  ringProximity: 4.0,          // how close to ring center (horizontal) to count as going through
  ringHeightTolerance: 3.0,    // y distance tolerance from ring center to count as passing through
  ringMultiplier: 2,
  ringDurationSec: 30
};

// 3 spawn zones (where blocks can't spawn). Each spawn zone also acts as a "save zone".
const SPAWN_ZONES = [
  { x: 0,  z: 0,  r: 12 },
  { x: 60, z: 40, r: 12 },
  { x: -60,z: -40,r: 12 }
];

const RAMPS = [
  { x: 20,  z: 20,  rotY: 0 },
  { x: -30, z: -10, rotY: Math.PI/2 },
  { x: 40,  z: -40, rotY: Math.PI/3 }
];

/* helper */
function rndRange(min,max){ return Math.random()*(max-min)+min; }
function dist2(a,b){ const dx=a.x-b.x, dz=a.z-b.z; return Math.hypot(dx,dz); }

/* ============================================================
   TRIANGULAR RAMP
============================================================ */
function makeTriRamp(scene) {
  const shape = [
    new BABYLON.Vector2(0,0),
    new BABYLON.Vector2(10,0),
    new BABYLON.Vector2(10,6),
    new BABYLON.Vector2(0,6)
  ];
  const depth = 4;

  const ramp = BABYLON.MeshBuilder.ExtrudePolygon(
    "triRamp",
    { shape, depth, sideOrientation: BABYLON.Mesh.DOUBLESIDE },
    scene
  );

  // rotate so the ramp faces upward nicely
  ramp.rotation.x = -Math.atan2(depth, 6);

  const m = new BABYLON.StandardMaterial("rampMat", scene);
  m.diffuseColor = BABYLON.Color3.Random();
  ramp.material = m;

  ramp.physicsImpostor = new BABYLON.PhysicsImpostor(
    ramp, BABYLON.PhysicsImpostor.MeshImpostor,
    { mass:0, friction:1, restitution:0 }, scene
  );

  return ramp;
}

/* ============================================================
   MAIN SCENE
============================================================ */
function createScene(){
  const scene = new BABYLON.Scene(engine);
  scene.clearColor = BABYLON.Color3.FromHexString(SETTINGS.skyColor);

  new BABYLON.HemisphericLight("light", new BABYLON.Vector3(0,1,0), scene);
  scene.enablePhysics(new BABYLON.Vector3(0, -9.81, 0), new BABYLON.CannonJSPlugin());

  /* ---------------- GROUND ---------------- */
  const groundSize = 300;
  const groundHeight = 10;
  const ground = BABYLON.MeshBuilder.CreateBox("ground", {
    width: groundSize, height: groundHeight, depth: groundSize
  }, scene);
  ground.position.y = -groundHeight/2; // top at y=0

  const matTop = new BABYLON.StandardMaterial("matTop", scene);
  matTop.diffuseColor = BABYLON.Color3.FromHexString(SETTINGS.groundTopColor);
  const matSide = new BABYLON.StandardMaterial("matSide", scene);
  matSide.diffuseColor = BABYLON.Color3.FromHexString(SETTINGS.groundSideColor);
  const multi = new BABYLON.MultiMaterial("groundMulti", scene);
  multi.subMaterials = [matSide, matSide, matSide, matSide, matTop, matSide];
  ground.material = multi;

  // assign submeshes (each face = 6 indices)
  ground.subMeshes = [];
  const vertices = ground.getTotalVertices();
  let indexStart = 0;
  for(let f=0; f<6; f++){
    new BABYLON.SubMesh(f, 0, vertices, indexStart, 6, ground);
    indexStart += 6;
  }

  ground.physicsImpostor = new BABYLON.PhysicsImpostor(
    ground, BABYLON.PhysicsImpostor.BoxImpostor,
    { mass:0, friction:2, restitution:0 }, scene
  );

  /* ---------------- WATER ---------------- */
  const water = BABYLON.MeshBuilder.CreateGround("water", {
    width: 700, height: 700
  }, scene);
  water.position.y = -4.2; // raised so you can jump in/out cleanly

  const waterMat = new BABYLON.WaterMaterial("waterMat", scene);
  waterMat.waveHeight = 0.35;
  waterMat.bumpHeight = 0.07;
  waterMat.windForce = 3.0;
  waterMat.waterColor = new BABYLON.Color3.FromHexString(SETTINGS.waterColor);
  water.material = waterMat;
  waterMat.addToRenderList(ground);

  /* ---------------- PLAYER ---------------- */
  const sphere = BABYLON.MeshBuilder.CreateSphere("player", { diameter:2 }, scene);
  sphere.position.set(0,3,0);
  const sphereMat = new BABYLON.StandardMaterial("sphereMat", scene);
  sphereMat.diffuseColor = new BABYLON.Color3(0.2, 0.6, 1.0);
  sphere.material = sphereMat;
  sphere.physicsImpostor = new BABYLON.PhysicsImpostor(
    sphere, BABYLON.PhysicsImpostor.SphereImpostor,
    { mass:1, friction:0.6, restitution:0.05 }, scene
  );

  /* ---------------- RAMPS (lifted) ---------------- */
  const ramps = RAMPS.map(r=>{
    const ramp = makeTriRamp(scene);
    ramp.position.set(r.x, 1.8, r.z); // LIFTED MORE so it sits well above ground
    ramp.rotation.y = r.rotY;
    return ramp;
  });
  function onRampBoost(){
    const v = sphere.physicsImpostor.getLinearVelocity();
    sphere.physicsImpostor.setLinearVelocity(new BABYLON.Vector3(v.x, 12, v.z));
  }

  /* ---------------- RINGS (one near each ramp) ---------------- */
  const rings = [];
  for(let i=0;i<ramps.length;i++){
    const r = ramps[i];
    const center = r.position.clone();
    center.y += SETTINGS.ringHeightOffset;
    // torus for ring visual; rotate so it's vertical
    const tor = BABYLON.MeshBuilder.CreateTorus("ring"+i, {
      diameter: SETTINGS.ringRadius*2,
      thickness: SETTINGS.ringThickness,
      tessellation: 48
    }, scene);
    tor.position.copyFrom(center);
    tor.rotation.x = Math.PI/2;
    const rm = new BABYLON.StandardMaterial("ringMat"+i, scene);
    rm.emissiveColor = new BABYLON.Color3(0.9, 0.6, 0.1);
    rm.alpha = 0.9;
    tor.material = rm;
    rings.push({mesh: tor, center: center, usedBy: new Set()}); // usedBy to avoid repeatedly granting
  }

  /* ------------------------------------------------------
     Helper: check if a location (x,z) is inside any spawn zone
  ------------------------------------------------------ */
  function insideAnySpawnZone(x,z){
    for(const s of SPAWN_ZONES){
      if(Math.hypot(x - s.x, z - s.z) < s.r) return true;
    }
    return false;
  }

  /* ----------------- RANDOM CUBES ----------------- */
  const cubes = [];
  for (let i=0;i<SETTINGS.cubeCount;i++){
    let x,z;
    let tries = 0;
    do {
      x = rndRange(-groundSize/2 + 8, groundSize/2 - 8);
      z = rndRange(-groundSize/2 + 8, groundSize/2 - 8);
      tries++;
    } while((Math.hypot(x,z) < SETTINGS.safeRadius || insideAnySpawnZone(x,z)) && tries < 300);

    const b = BABYLON.MeshBuilder.CreateBox("cube"+i,{size:SETTINGS.cubeSize},scene);
    b.position.set(x, SETTINGS.cubeSize/2 + 0.1, z);
    const m = new BABYLON.StandardMaterial("cubeMat"+i, scene);
    m.diffuseColor = BABYLON.Color3.Random();
    b.material = m;
    b.physicsImpostor = new BABYLON.PhysicsImpostor(
      b, BABYLON.PhysicsImpostor.BoxImpostor,
      { mass:1, friction:1, restitution:0.05 }, scene
    );
    cubes.push(b);
  }

  /* ----------------- HILLS ----------------- */
  const hills = [];
  const hillCount = SETTINGS.hillCount;
  for(let i=0;i<hillCount;i++){
    let x,z,tries=0;
    do {
      x = rndRange(-groundSize/2 + 20, groundSize/2 - 20);
      z = rndRange(-groundSize/2 + 20, groundSize/2 - 20);
      tries++;
    } while((Math.hypot(x,z) < SETTINGS.safeRadius || insideAnySpawnZone(x,z)) && tries < 500);

    const size = rndRange(6, 16);
    const hill = BABYLON.MeshBuilder.CreateBox("hill"+i, { width:size, height:size/2, depth:size }, scene);
    hill.position.set(x, size/4 + 0.1, z);

    // style like ground: MultiMaterial top and sides
    const topMat = new BABYLON.StandardMaterial("hillTop"+i, scene);
    topMat.diffuseColor = BABYLON.Color3.FromHexString(SETTINGS.groundTopColor);
    const sideMat = new BABYLON.StandardMaterial("hillSide"+i, scene);
    sideMat.diffuseColor = BABYLON.Color3.FromHexString(SETTINGS.groundSideColor);
    const hm = new BABYLON.MultiMaterial("hillMulti"+i, scene);
    hm.subMaterials = [sideMat,sideMat,sideMat,sideMat,topMat,sideMat];
    hill.material = hm;

    hill.subMeshes = [];
    const vcount = hill.getTotalVertices();
    let idxStart = 0;
    for(let f=0; f<6; f++){
      new BABYLON.SubMesh(f, 0, vcount, idxStart, 6, hill);
      idxStart+=6;
    }

    hill.physicsImpostor = new BABYLON.PhysicsImpostor(
      hill, BABYLON.PhysicsImpostor.BoxImpostor,
      { mass:0, friction:1, restitution:0 }, scene
    );
    hills.push(hill);
  }

  /* ----------------- ARROWS ----------------- */
  function makeArrow(name,color){
    const p = BABYLON.MeshBuilder.CreatePlane(name,{size:1},scene);
    const mm = new BABYLON.StandardMaterial(name+"Mat",scene);
    mm.diffuseColor = BABYLON.Color3.FromHexString(color);
    p.material = mm;
    p.billboardMode = BABYLON.Mesh.BILLBOARDMODE_ALL;
    p.parent = sphere;
    p.position.set(0,1.5,-2);
    return p;
  }
  const arrowF = makeArrow("aF", "#00FF00");
  const arrowB = (() => { const a=makeArrow("aB","#FF0000"); a.position.set(0,1.5,2); return a; })();
  const arrowL = (() => { const a=makeArrow("aL","#00A2FF"); a.position.set(-2,1.5,0); return a; })();
  const arrowR = (() => { const a=makeArrow("aR","#FFD800"); a.position.set(2,1.5,0); return a; })();

  function updateArrows(i){
    arrowF.material.emissiveColor = i.forward ? BABYLON.Color3.White() : BABYLON.Color3.Black();
    arrowB.material.emissiveColor = i.back ? BABYLON.Color3.White() : BABYLON.Color3.Black();
    arrowL.material.emissiveColor = i.left ? BABYLON.Color3.White() : BABYLON.Color3.Black();
    arrowR.material.emissiveColor = i.right ? BABYLON.Color3.White() : BABYLON.Color3.Black();
  }

  /* ----------------- COINS ----------------- */
  const coinMaterial = new BABYLON.StandardMaterial("coinMat", scene);
  coinMaterial.diffuseColor = new BABYLON.Color3(0.95,0.77,0.15);
  coinMaterial.emissiveColor = new BABYLON.Color3(0.7,0.5,0.05);

  const coins = [];
  const coinState = []; // { active: bool, timerId: number|null }
  const coinRadius = 1.0;

  function findSafeCoinPosition(){
    const margin = 8;
    const attempts = 300;
    for(let i=0;i<attempts;i++){
      const x = rndRange(-groundSize/2 + margin, groundSize/2 - margin);
      const z = rndRange(-groundSize/2 + margin, groundSize/2 - margin);
      if(Math.hypot(x, z) < SETTINGS.safeRadius*0.8) continue;
      if(insideAnySpawnZone(x,z)) continue;
      let ok = true;
      for(const c of coins){
        if(c && c.position && Math.hypot(c.position.x - x, c.position.z - z) < 3){ ok=false; break; }
      }
      if(!ok) continue;
      return {x,z};
    }
    return {x: 10, z: 10};
  }

  function spawnSingleCoin(i){
    let pos = findSafeCoinPosition();
    if(!coins[i]){
      const tor = BABYLON.MeshBuilder.CreateTorus("coin"+i, {thickness:0.2, diameter:1.0, tessellation:24}, scene);
      tor.rotation.x = Math.PI/2;
      tor.material = coinMaterial;
      tor.position.y = 1.2;
      coins[i] = tor;
      coinState[i] = {active:true, timerId:null};
    }
    coins[i].position.x = pos.x;
    coins[i].position.z = pos.z;
    coins[i].isVisible = true;
    coinState[i].active = true;
  }

  const coinCap = SETTINGS.coinMax;
  for(let i=0;i<coinCap;i++){
    spawnSingleCoin(i);
  }

  function hideAndScheduleRespawn(i){
    if(!coins[i]) return;
    coins[i].isVisible = false;
    coinState[i].active = false;
    const ms = SETTINGS.coinRespawnSec * 1000;
    if(coinState[i].timerId) clearTimeout(coinState[i].timerId);
    coinState[i].timerId = setTimeout(()=>{
      spawnSingleCoin(i);
      coinState[i].timerId = null;
    }, ms);
  }

  /* ----------------- INPUT & CAMERA ----------------- */
  const input = { forward:false, back:false, left:false, right:false, jump:false };
  window.addEventListener("keydown", e=>{
    const k = e.key.toLowerCase();
    if(k==="w") input.forward=true;
    if(k==="s") input.back=true;
    if(k==="a") input.left=true;
    if(k==="d") input.right=true;
    if(e.code === "Space") input.jump = true;
  });
  window.addEventListener("keyup", e=>{
    const k = e.key.toLowerCase();
    if(k==="w") input.forward=false;
    if(k==="s") input.back=false;
    if(k==="a") input.left=false;
    if(k==="d") input.right=false;
    if(e.code === "Space") input.jump = false;
  });

  const camera = new BABYLON.ArcRotateCamera("cam", 0, BABYLON.Tools.ToRadians(55), 14, sphere.position.clone(), scene);
  camera.attachControl(canvas, true);
  camera.lowerRadiusLimit = 6;
  camera.upperRadiusLimit = 40;

  /* ============================================================
     GAME STATE: coins collected & multiplier
  ============================================================ */
  let coinsCollected = 0;
  let multiplierActive = false;
  let multiplierExpireAt = 0; // epoch ms
  const coinCounterEl = document.getElementById("coinsValue");
  const multEl = document.getElementById("multiplier");
  const multTimeEl = document.getElementById("multTime");

  function setMultiplierActive(active){
    multiplierActive = active;
    if(!active){
      multEl.style.display = "none";
    } else {
      multEl.style.display = "block";
    }
  }
  setMultiplierActive(false);

  function grantMultiplier(durationSec){
    const now = Date.now();
    multiplierExpireAt = Math.max(multiplierExpireAt, now) + durationSec*1000;
    setMultiplierActive(true);
  }

  /* ============================================================
     MULTIPLAYER (lightweight sync)
     - Simple WebSocket-based broadcast protocol (optional)
     - If signaling server not set, client stays singleplayer but still shows UI
     Protocol (JSON messages):
       { type: "join", room, id }
       { type: "state", room, id, x, y, z, colorHex, coinsCollected }
       { type: "leave", room, id }
     The server should broadcast messages to all clients in same room.
  ============================================================ */
  let socket = null;
  let playerId = Math.random().toString(36).slice(2,10);
  let room = "";
  let SIGNALING_SERVER = ""; // set by UI input
  const otherPlayers = new Map(); // id -> {mesh, lastUpdated, coins}
  const otherCountEl = document.getElementById("otherCount");
  const otherPlayersLabel = document.getElementById("otherPlayersLabel");
  const netStatus = document.getElementById("netStatus");

  function connectNetworking(url, roomId){
    if(socket){ try { socket.close(); } catch(e){} }
    SIGNALING_SERVER = url;
    room = roomId || "";
    if(!SIGNALING_SERVER){
      netStatus.textContent = "No signaling server set (local-only).";
      return;
    }
    try {
      socket = new WebSocket(SIGNALING_SERVER);
    } catch(e){
      netStatus.textContent = "Failed to create WebSocket.";
      return;
    }
    socket.onopen = ()=> {
      netStatus.textContent = "Connected. Joining room: " + room;
      // send join
      socket.send(JSON.stringify({ type:"join", room, id: playerId }));
      // send initial state quickly
      sendState();
    };
    socket.onmessage = (ev)=>{
      try {
        const msg = JSON.parse(ev.data);
        if(msg.id === playerId) return; // ignore own messages
        if(msg.type === "state"){
          if(msg.room !== room) return;
          // update or create other player
          let op = otherPlayers.get(msg.id);
          if(!op){
            // create sphere for other player
            const s = BABYLON.MeshBuilder.CreateSphere("other_"+msg.id, {diameter:1.8}, scene);
            const m = new BABYLON.StandardMaterial("otherMat_"+msg.id, scene);
            if(msg.colorHex) {
              try {
                m.diffuseColor = BABYLON.Color3.FromHexString(msg.colorHex);
              } catch(e){ m.diffuseColor = BABYLON.Color3.Random(); }
            } else {
              m.diffuseColor = BABYLON.Color3.Random();
            }
            s.material = m;
            otherPlayers.set(msg.id, { mesh: s, lastUpdated: Date.now(), coins: msg.coins || 0 });
            otherPlayersLabel.style.display = "block";
          }
          op = otherPlayers.get(msg.id);
          if(op){
            op.mesh.position.set(msg.x, msg.y, msg.z);
            op.lastUpdated = Date.now();
            op.coins = msg.coins || op.coins;
          }
        } else if(msg.type === "join"){
          // optional: show join
        } else if(msg.type === "leave"){
          if(otherPlayers.has(msg.id)){
            const op = otherPlayers.get(msg.id);
            try { op.mesh.dispose(); } catch(e){}
            otherPlayers.delete(msg.id);
          }
        }
        otherCountEl.textContent = otherPlayers.size;
      } catch(e){
        console.warn("bad ws message", e);
      }
    };
    socket.onclose = ()=> netStatus.textContent = "Disconnected.";
    socket.onerror = (e)=> netStatus.textContent = "WebSocket error.";
  }

  function sendState(){
    if(!socket || socket.readyState !== WebSocket.OPEN) return;
    const colorHex = sphere.material && sphere.material.diffuseColor ? "#" + sphere.material.diffuseColor.toHexString().slice(1) : null;
    const msg = {
      type: "state",
      room,
      id: playerId,
      x: sphere.position.x,
      y: sphere.position.y,
      z: sphere.position.z,
      colorHex,
      coins: coinsCollected
    };
    socket.send(JSON.stringify(msg));
  }

  // UI hookup for networking
  document.getElementById("connectBtn").addEventListener("click", ()=>{
    const roomVal = document.getElementById("roomInput").value.trim();
    const serverVal = document.getElementById("serverInput").value.trim();
    connectNetworking(serverVal, roomVal);
  });

  /* ============================================================
     MAIN GAME LOOP
  ============================================================ */
  let lastMove = new BABYLON.Vector3(0,0,1);
  const worldForward = new BABYLON.Vector3(0,0,1);
  const worldRight   = new BABYLON.Vector3(1,0,0);

  function grounded(){
    const ray = new BABYLON.Ray(sphere.position, new BABYLON.Vector3(0,-1,0), 1.2);
    const hit = scene.pickWithRay(ray, m => m !== sphere);
    return hit && hit.hit;
  }

  function clampVel(v){
    const h = new BABYLON.Vector3(v.x,0,v.z);
    const l = h.length();
    if(l > SETTINGS.maxSpeed){
      h.scaleInPlace(SETTINGS.maxSpeed/l);
      return new BABYLON.Vector3(h.x, v.y, h.z);
    }
    return v;
  }

  scene.registerBeforeRender(()=>{
    updateArrows(input);

    // movement dir (world-space)
    let dir = BABYLON.Vector3.Zero();
    if(input.forward) dir.addInPlace(worldForward);
    if(input.back)    dir.subtractInPlace(worldForward);
    if(input.left)    dir.subtractInPlace(worldRight);
    if(input.right)   dir.addInPlace(worldRight);

    if(dir.lengthSquared() > 0.001){
      dir.normalize();
      lastMove.copyFrom(dir);
    }

    // physics velocity & damping
    const v = sphere.physicsImpostor.getLinearVelocity();
    const damped = new BABYLON.Vector3(v.x*SETTINGS.damp, v.y, v.z*SETTINGS.damp);

    if(dir.length()>0.001){
      sphere.physicsImpostor.setLinearVelocity(
        clampVel(damped.add(dir.scale(SETTINGS.moveForce * engine.getDeltaTime()*0.06)))
      );
    } else {
      sphere.physicsImpostor.setLinearVelocity(new BABYLON.Vector3(damped.x, v.y, damped.z));
    }

    // jump (on ground)
    if(input.jump && grounded()){
      const v2 = sphere.physicsImpostor.getLinearVelocity();
      sphere.physicsImpostor.setLinearVelocity(new BABYLON.Vector3(v2.x, SETTINGS.jumpForce, v2.z));
    }

    // swim behaviour
    const swimThreshold = water.position.y + 1.2;
    if(sphere.position.y < swimThreshold){
      sphere.physicsImpostor.setLinearVelocity(
        new BABYLON.Vector3(v.x * 0.9, v.y + 0.08, v.z * 0.9)
      );
      if(input.jump){
        sphere.physicsImpostor.setLinearVelocity(new BABYLON.Vector3(v.x, SETTINGS.swimUpSpeed, v.z));
      }
    }

    // ramp boost detection
    for(const ramp of ramps){
      if(BABYLON.Vector3.Distance(sphere.position, ramp.position) < 6){
        onRampBoost();
      }
    }

    // ring detection: if player is within horizontal proximity of ring center AND within height tolerance,
    // grant multiplier. We use rings[].usedBy to avoid granting repeatedly while staying within ring.
    for(const ring of rings){
      const dx = sphere.position.x - ring.center.x;
      const dz = sphere.position.z - ring.center.z;
      const horizDist = Math.hypot(dx, dz);
      const heightDiff = Math.abs(sphere.position.y - ring.center.y);
      if(horizDist < SETTINGS.ringProximity && heightDiff < SETTINGS.ringHeightTolerance){
        if(!ring.usedBy.has(playerId)){
          // grant multiplier
          grantMultiplier(SETTINGS.ringDurationSec);
          ring.usedBy.add(playerId);
          // visual pulse (scale up then back)
          const s = ring.mesh;
          BABYLON.Animation.CreateAndStartAnimation("pulse", s, "scaling.x", 30, 12, s.scaling.x, s.scaling.x*1.4, BABYLON.Animation.ANIMATIONLOOPMODE_CYCLE);
          BABYLON.Animation.CreateAndStartAnimation("pulsey", s, "scaling.y", 30, 12, s.scaling.y, s.scaling.y*1.4, BABYLON.Animation.ANIMATIONLOOPMODE_CYCLE);
        }
      } else {
        // leaving ring area: remove flag so you can re-trigger next time you re-enter
        if(ring.usedBy.has(playerId)){
          ring.usedBy.delete(playerId);
        }
      }
    }

    // coin pickup detection
    for(let i=0;i<coins.length;i++){
      const coin = coins[i];
      if(!coin || !coin.isVisible) continue;
      const d = Math.hypot(coin.position.x - sphere.position.x, coin.position.z - sphere.position.z);
      const heightDiff = Math.abs(coin.position.y - sphere.position.y);
      if(d < 1.3 && heightDiff < 2.2){
        // picked up
        hideAndScheduleRespawn(i);
        let award = 1;
        if(multiplierActive && Date.now() < multiplierExpireAt) {
          award *= SETTINGS.ringMultiplier;
        }
        coinsCollected += award;
        coinCounterEl.textContent = coinsCollected;
        // send state to peers
        sendState();
      }
    }

    // multiplier UI update
    if(multiplierActive){
      const remaining = Math.max(0, Math.ceil((multiplierExpireAt - Date.now())/1000));
      multTimeEl.textContent = remaining;
      if(remaining <= 0){
        setMultiplierActive(false);
      }
    }

    // respawn safeguards
    if(sphere.position.y < SETTINGS.respawnY){
      sphere.position.set(0,6,0);
      sphere.physicsImpostor.setLinearVelocity(BABYLON.Vector3.Zero());
    }

    // camera follow
    camera.target = BABYLON.Vector3.Lerp(camera.target, sphere.position, 0.35);

    // occasionally send our state to other players (throttled)
    if(Math.random() < 0.06) sendState();

    // cleanup stale other players (if no update for a while)
    const now = Date.now();
    for(const [id,op] of Array.from(otherPlayers.entries())){
      if(now - op.lastUpdated > 12000){ // 12s stale
        try { op.mesh.dispose(); } catch(e){}
        otherPlayers.delete(id);
      }
    }
    otherCountEl.textContent = otherPlayers.size;
    otherPlayersLabel.style.display = otherPlayers.size>0 ? "block" : "none";
  });

  return scene;
}

/* ============================================================
   START ENGINE
============================================================ */
const scene = createScene();
engine.runRenderLoop(()=> scene.render());
window.addEventListener("resize", () => engine.resize());
</script>
</body>
</html>
