<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<title>Babylon — 3rd Person Sphere (Multiplayer, Rings, Day/Night, Hills & Textured Cubes)</title>
<link rel="icon" href="awodas.png" type="image/png">
<style>
  html, body { width:100%; height:100%; margin:0; overflow:hidden; font-family:Inter, system-ui, sans-serif; }
  #renderCanvas { width:100%; height:100%; touch-action:none; display:block; }
  #ui { position:absolute; left:12px; top:12px; z-index:50; color:white; text-shadow:0 2px 6px rgba(0,0,0,0.7); pointer-events:none; }
  #coinCounter { background: rgba(0,0,0,0.45); padding:10px 14px; border-radius:8px; font-size:18px; min-width:120px; }
  #multiplier { margin-top:8px; background: rgba(0,0,0,0.35); padding:8px 12px; border-radius:8px; font-size:14px; display:none; }
  #netStatus { position:absolute; right:12px; bottom:12px; z-index:50; color:white; font-size:12px; background:rgba(0,0,0,0.25); padding:6px 8px; border-radius:6px; display:none; }
</style>

<!-- BabylonJS Libraries -->
<script src="https://cdn.babylonjs.com/babylon.js"></script>
<script src="https://cdn.babylonjs.com/materialsLibrary/babylon.waterMaterial.min.js"></script>
<script src="https://cdn.babylonjs.com/earcut.min.js"></script>
<script src="https://cdn.babylonjs.com/cannon.js"></script>
</head>
<body>
<canvas id="renderCanvas"></canvas>

<div id="ui">
  <div id="coinCounter">Coins: <span id="coinsValue">0</span></div>
  <div id="multiplier">Multiplier: <span id="multValue">2x</span> — <span id="multTime">30</span>s</div>
</div>
<div id="netStatus">Net: connecting...</div>

<script>
// ==================== SETTINGS ====================
const canvas = document.getElementById("renderCanvas");
const engine = new BABYLON.Engine(canvas, true);

const SETTINGS = {
  groundTopColor: "#33FF4B",
  groundSideColor: "#8B5A2B",
  waterColor: "#4DA6FF",
  dayColor: "#9DE9FF",
  nightColor: "#1B2432",
  cubeCount: 30,
  hillCount: 10,
  treeCount: 40,
  respawnY: -60,
  moveForce: 7.5,
  maxSpeed: 8,
  jumpForce: 6.6,
  damp: 0.92,
  cubeSize: 2,
  safeRadius: 8,
  swimUpSpeed: 4,
  coinMax: 32,
  coinRespawnSec: 45,
  ringRadius: 5,
  ringThickness: 0.6,
  ringHeightOffset: 6,
  ringProximity: 4,
  ringHeightTolerance: 3,
  ringMultiplier: 2,
  ringDurationSec: 30,
  dayNightCycleMs: 5*60*1000,
  coatTexture: "box-texture.png",
  coatSize: 2.04
};

const SPAWN_ZONES = [
  { x: 0, z: 0, r: 12 },
  { x: 60, z: 40, r: 12 },
  { x: -60, z: -40, r: 12 }
];

const RAMPS = [
  { x: 20, z: 20, rotY: 0 },
  { x: -30, z: -10, rotY: Math.PI/2 },
  { x: 40, z: -40, rotY: Math.PI/3 }
];

// ==================== HELPERS ====================
function rndRange(min,max){ return Math.random()*(max-min)+min; }
function color3FromHex(hex){ return BABYLON.Color3.FromHexString(hex); }
function lerpColor(hexA, hexB, t){
  const a=color3FromHex(hexA), b=color3FromHex(hexB);
  return new BABYLON.Color3(a.r+(b.r-a.r)*t, a.g+(b.g-a.g)*t, a.b+(b.b-a.b)*t);
}

// ==================== CREATE TRIANGULAR RAMPS ====================
function makeTriRamp(scene,nameSuffix=""){
  const shape=[new BABYLON.Vector2(0,0), new BABYLON.Vector2(10,0), new BABYLON.Vector2(0,6)];
  const depth = 6;
  const ramp = BABYLON.MeshBuilder.ExtrudePolygon("triRamp"+nameSuffix, {shape, depth, sideOrientation:BABYLON.Mesh.DOUBLESIDE}, scene);
  ramp.rotation.x = -Math.atan2(depth,6);
  const mat = new BABYLON.StandardMaterial("rampMat"+nameSuffix, scene);
  mat.diffuseColor = BABYLON.Color3.Random();
  ramp.material = mat;
  ramp.physicsImpostor = new BABYLON.PhysicsImpostor(ramp,BABYLON.PhysicsImpostor.MeshImpostor,{mass:0,friction:1,restitution:0},scene);
  ramp._rampParams={depth, shapeWidth:10, shapeHeight:6};
  return ramp;
}

// ==================== CREATE SCENE ====================
function createScene(){
  const scene = new BABYLON.Scene(engine);
  scene.clearColor = color3FromHex(SETTINGS.dayColor);
  scene.enablePhysics(new BABYLON.Vector3(0,-9.81,0), new BABYLON.CannonJSPlugin());

  // Lights
  const hemi = new BABYLON.HemisphericLight("hemi", new BABYLON.Vector3(0,1,0), scene);
  hemi.intensity = 0.9;
  const sun = new BABYLON.DirectionalLight("sun", new BABYLON.Vector3(-0.2,-1,0.2), scene);
  sun.position = new BABYLON.Vector3(0,50,0);
  sun.intensity = 1.0;

  // Ground
  const groundSize = 300;
  const groundVis = BABYLON.MeshBuilder.CreateGround("groundVis",{width:groundSize,height:groundSize,subdivisions:4},scene);
  groundVis.position.y = 0;
  const groundMat = new BABYLON.StandardMaterial("groundVisMat",scene);
  groundMat.diffuseColor = color3FromHex(SETTINGS.groundTopColor);
  groundVis.material = groundMat;
  const groundPhys = BABYLON.MeshBuilder.CreateBox("groundPhys",{width:groundSize,height:10,depth:groundSize},scene);
  groundPhys.position.y = -5;
  groundPhys.isVisible=false;
  groundPhys.physicsImpostor = new BABYLON.PhysicsImpostor(groundPhys,BABYLON.PhysicsImpostor.BoxImpostor,{mass:0,friction:2,restitution:0},scene);

  // Water
  const water = BABYLON.MeshBuilder.CreateGround("water",{width:700,height:700},scene);
  water.position.y=-4.2;
  const waterMat = new BABYLON.WaterMaterial("waterMat",scene);
  waterMat.waveHeight=0.35; waterMat.bumpHeight=0.07; waterMat.windForce=3;
  waterMat.waterColor = color3FromHex(SETTINGS.waterColor);
  water.material = waterMat;
  waterMat.addToRenderList(groundVis);

  // Player
  const sphere = BABYLON.MeshBuilder.CreateSphere("player",{diameter:2},scene);
  sphere.position.set(0,3,0);
  const sphereMat = new BABYLON.StandardMaterial("sphereMat",scene);
  sphereMat.diffuseColor = new BABYLON.Color3(0.2,0.6,1.0);
  sphere.material = sphereMat;
  sphere.physicsImpostor = new BABYLON.PhysicsImpostor(sphere,BABYLON.PhysicsImpostor.SphereImpostor,{mass:1,friction:0.6,restitution:0.05},scene);

  // ==================== RAMPS ====================
  const ramps=[], rampTriggers=[];
  for(const r of RAMPS){
    const ramp = makeTriRamp(scene,"_"+r.x+"_"+r.z);
    ramp.position.set(r.x,1.8,r.z);
    ramp.rotation.y = r.rotY;
    ramps.push(ramp);
    rampTriggers.push({ramp, worldTrigger: ramp.position.add(new BABYLON.Vector3(0,2.2,0)), forward: new BABYLON.Vector3(Math.sin(r.rotY),0,Math.cos(r.rotY))});
  }
  function onRampBoost(trigger){
    const impulse = trigger.forward.normalize().scale(8);
    sphere.physicsImpostor.setLinearVelocity(new BABYLON.Vector3(impulse.x,12,impulse.z));
  }

  // Rings
  const rings=[];
  for(let i=0;i<ramps.length;i++){
    const ramp = ramps[i];
    const center = ramp.position.clone();
    center.y += SETTINGS.ringHeightOffset;
    const tor = BABYLON.MeshBuilder.CreateTorus("ring"+i,{diameter:SETTINGS.ringRadius*2,thickness:SETTINGS.ringThickness,tessellation:48},scene);
    tor.position.copyFrom(center);
    tor.rotation.x=Math.PI/2;
    tor.rotation.y = ramp.rotation.y||0;
    const rm = new BABYLON.StandardMaterial("ringMat"+i,scene);
    rm.emissiveColor = new BABYLON.Color3(0.9,0.6,0.1);
    rm.alpha = 0.95;
    tor.material=rm;
    rings.push({mesh:tor, center, usedBy:new Set(), rampIndex:i});
  }

    socket.send(JSON.stringify(msg));
  }

  /* ============================================================
      MOVEMENT, PHYSICS UPDATE, GRAVITY + WATER SWIM LOGIC
  ============================================================ */
  let onGround = false;
  let jumpCooldown = 0;

  function applyMovement() {
    const vel = sphere.physicsImpostor.getLinearVelocity();
    if(!vel) return;

    // water detection
    const inWater = sphere.position.y < -3.9;

    // movement direction based on camera forward projected on XZ
    const forward = camera.getFrontPosition(1).subtract(camera.position);
    forward.y = 0; forward.normalize();
    const right = new BABYLON.Vector3(forward.z, 0, -forward.x);

    let move = new BABYLON.Vector3(0,0,0);
    if(input.forward) move.addInPlace(forward);
    if(input.back)    move.addInPlace(forward.scale(-1));
    if(input.left)    move.addInPlace(right.scale(-1));
    if(input.right)   move.addInPlace(right);

    if(move.length() > 0){
      move.normalize();
      move.scaleInPlace(SETTINGS.moveForce);
      vel.x += move.x;
      vel.z += move.z;
    }

    // limit speed
    const speedXZ = Math.hypot(vel.x, vel.z);
    if(speedXZ > SETTINGS.maxSpeed){
      const scale = SETTINGS.maxSpeed / speedXZ;
      vel.x *= scale; vel.z *= scale;
    }

    // ground check
    onGround = (Math.abs(vel.y) < 0.15 && sphere.position.y <= 2.2);

    // jump
    if(input.jump && onGround && jumpCooldown < Date.now()){
      vel.y = SETTINGS.jumpForce;
      jumpCooldown = Date.now() + 200;
    }

    // water buoyancy & slow movement
    if(inWater){
      vel.y += 0.065;
      if(input.jump){
        vel.y += SETTINGS.swimUpSpeed * 0.06;
      }
    }

    // apply dampening (XZ only)
    vel.x *= SETTINGS.damp;
    vel.z *= SETTINGS.damp;

    sphere.physicsImpostor.setLinearVelocity(vel);
  }

  /* ============================================================
      CAMERA FOLLOW: TIGHTER TRAILING
  ============================================================ */
  function updateCamera() {
    const target = sphere.position.clone();
    camera.target = BABYLON.Vector3.Lerp(camera.target, target, 0.25);
  }

  /* ============================================================
      RAMP BOOST CHECK
  ============================================================ */
  function checkRamps(){
    for(const t of rampTriggers){
      const dx = sphere.position.x - t.worldTrigger.x;
      const dy = sphere.position.y - t.worldTrigger.y;
      const dz = sphere.position.z - t.worldTrigger.z;
      const dist = Math.hypot(dx, dz);
      if(dist < 3 && Math.abs(dy) < 3){
        onRampBoost(t);
      }
    }
  }

  /* ============================================================
      RING MULTIPLIER CHECK
  ============================================================ */
  function updateMultiplierUI(){
    if(!multiplierActive) return;
    const left = Math.floor((multiplierExpireAt - Date.now())/1000);
    if(left <= 0){
      setMultiplierActive(false);
      return;
    }
    multTimeEl.textContent = left;
  }

  function checkRings(){
    for(const r of rings){
      if(r.usedBy.has(playerId)) continue;
      const dx = sphere.position.x - r.center.x;
      const dy = sphere.position.y - r.center.y;
      const dz = sphere.position.z - r.center.z;
      if(Math.hypot(dx,dz) < SETTINGS.ringProximity && Math.abs(dy) < SETTINGS.ringHeightTolerance){
        r.usedBy.add(playerId);
        grantMultiplier(SETTINGS.ringDurationSec);
      }
    }
  }

  /* ============================================================
      COIN PICKUP
  ============================================================ */
  function checkCoins(){
    for(const c of coins){
      if(!c.active) continue;
      const dx = sphere.position.x - c.mesh.position.x;
      const dz = sphere.position.z - c.mesh.position.z;
      if(Math.hypot(dx,dz) < 1.3){
        // pickup
        c.active = false;
        c.mesh.isVisible = false;

        let add = 1;
        if(multiplierActive) add *= SETTINGS.ringMultiplier;
        coinsCollected += add;
        coinCounterEl.textContent = coinsCollected;

        // send to server
        if(socket && socket.readyState === WebSocket.OPEN){
          socket.send(JSON.stringify({ type:"coinPicked", room, id:c.id, player:playerId }));
        }
      }
    }
  }

  /* ============================================================
      DAY / NIGHT CYCLE (smooth sky color)
  ============================================================ */
  function updateDayNight(){
    const t = (Date.now() % SETTINGS.dayNightCycleMs) / SETTINGS.dayNightCycleMs;  
    let phase = t < 0.5 ? t * 2 : (1 - t) * 2;
    const col = lerpColor(SETTINGS.dayColor, SETTINGS.nightColor, 1 - phase);
    scene.clearColor = col;
  }

  /* ============================================================
      RESPAWN FALLING
  ============================================================ */
  function checkRespawn(){
    if(sphere.position.y < SETTINGS.respawnY){
      sphere.position.set(0,6,0);
      sphere.physicsImpostor.setLinearVelocity(new BABYLON.Vector3(0,0,0));
    }
  }

  /* ============================================================
      GAME LOOP
  ============================================================ */
  scene.onBeforeRenderObservable.add(()=>{
    applyMovement();
    updateCamera();
    checkRamps();
    checkRings();
    checkCoins();
    updateDayNight();
    updateMultiplierUI();
    checkRespawn();
    updateArrows(input);
    sendState();
  });

  return scene;
}

/* ============================================================
    START ENGINE
============================================================ */
const scene = createScene();
engine.runRenderLoop(()=>{ scene.render(); });
window.addEventListener("resize", ()=>engine.resize());
</script>
</body>
</html>

</script>
</body>
</html>
