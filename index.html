<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8" />
  <title>Babylon — 3rd Person Sphere (Fixed)</title>
  <link rel="icon" href="awodas.png" type="image/png">
  <style>
    html,body { width:100%; height:100%; margin:0; overflow:hidden; font-family: Inter, system-ui, sans-serif; }
    #renderCanvas { width:100%; height:100%; touch-action:none; display:block; }
    #ui { position: absolute; left: 12px; top: 12px; z-index: 50; color: white; text-shadow: 0 2px 6px rgba(0,0,0,0.7); user-select: none; }
    #coinCounter { background: rgba(0,0,0,0.45); padding: 10px 14px; border-radius: 8px; font-size: 18px; min-width: 120px; }
    #multiplier { margin-top: 8px; background: rgba(0,0,0,0.35); padding: 8px 12px; border-radius: 8px; font-size: 14px; }
    #netUI { position: absolute; right: 12px; top: 12px; z-index: 50; color: white; font-size: 13px; }
    #netUI input { padding:6px; border-radius:6px; border:none; margin-right:6px; }
    #netUI button { padding:6px 10px; border-radius:6px; border:none; cursor:pointer; }
    #otherPlayersLabel { position: absolute; right: 12px; top: 70px; z-index: 50; color: white; font-size: 13px; background: rgba(0,0,0,0.35); padding:8px; border-radius:8px; }
  </style>

  <!-- Babylon -->
  <script src="https://cdn.babylonjs.com/babylon.js"></script>
  <script src="https://cdn.babylonjs.com/materialsLibrary/babylon.waterMaterial.min.js"></script>
  <script src="https://cdn.babylonjs.com/earcut.min.js"></script>
  <script src="https://cdn.babylonjs.com/cannon.js"></script>
</head>
<body>
<canvas id="renderCanvas"></canvas>

<div id="ui">
  <div id="coinCounter">Coins: <span id="coinsValue">0</span></div>
  <div id="multiplier" style="display:none;">Multiplier: <span id="multValue">2x</span> — <span id="multTime">30</span>s</div>
</div>

<div id="netUI">
  <input id="roomInput" placeholder="room id (optional)" />
  <input id="serverInput" placeholder="ws://localhost:8080" style="width:220px"/>
  <button id="connectBtn">Connect</button>
  <div id="netStatus" style="margin-top:6px;font-size:12px;opacity:0.9"></div>
</div>

<div id="otherPlayersLabel" style="display:none;">Other Players: <span id="otherCount">0</span></div>

<script>
/* ============================================================
   INIT + SETTINGS
============================================================ */
const canvas = document.getElementById("renderCanvas");
const engine = new BABYLON.Engine(canvas, true);

const SETTINGS = {
  groundTopColor:  "#33FF4B",
  groundSideColor: "#8B5A2B",
  waterColor:      "#4DA6FF",
  skyColor:        "#9DE9FF",

  cubeCount: 30,
  hillCount: 10,
  treeCount: 40,
  respawnY: -60,

  moveForce: 7.5,
  maxSpeed:  8,
  jumpForce: 6.6,
  damp: 0.92,

  cubeSize:    2,
  safeRadius:  8,

  swimUpSpeed: 4,
  coinMax: 32,
  coinRespawnSec: 45,

  ringRadius: 5.0,
  ringThickness: 0.6,
  ringHeightOffset: 6.0,
  ringProximity: 4.0,
  ringHeightTolerance: 3.0,
  ringMultiplier: 2,
  ringDurationSec: 30
};

const SPAWN_ZONES = [
  { x: 0,  z: 0,  r: 12 },
  { x: 60, z: 40, r: 12 },
  { x: -60,z: -40,r: 12 }
];

const RAMPS = [
  { x: 20,  z: 20,  rotY: 0 },
  { x: -30, z: -10, rotY: Math.PI/2 },
  { x: 40,  z: -40, rotY: Math.PI/3 }
];

function rndRange(min,max){ return Math.random()*(max-min)+min; }

function makeTriRamp(scene) {
  const shape = [
    new BABYLON.Vector2(0,0),
    new BABYLON.Vector2(10,0),
    new BABYLON.Vector2(10,6),
    new BABYLON.Vector2(0,6)
  ];
  const depth = 4;
  const ramp = BABYLON.MeshBuilder.ExtrudePolygon("triRamp",{shape, depth, sideOrientation: BABYLON.Mesh.DOUBLESIDE}, scene);
  ramp.rotation.x = -Math.atan2(depth,6);
  const m = new BABYLON.StandardMaterial("rampMat", scene);
  m.diffuseColor = BABYLON.Color3.Random();
  ramp.material = m;
  ramp.physicsImpostor = new BABYLON.PhysicsImpostor(ramp, BABYLON.PhysicsImpostor.MeshImpostor, { mass:0, friction:1, restitution:0 }, scene);
  ramp._rampParams = { depth, shapeWidth:10, shapeHeight:6 };
  return ramp;
}

/* ============================================================
   DUMMY VARIABLES FOR STABILITY
============================================================ */
const input = {forward:false,back:false,left:false,right:false,jump:false};
window.addEventListener("keydown",(e)=>{
  if(e.key==="w") input.forward=true;
  if(e.key==="s") input.back=true;
  if(e.key==="a") input.left=true;
  if(e.key==="d") input.right=true;
  if(e.key===" ") input.jump=true;
});
window.addEventListener("keyup",(e)=>{
  if(e.key==="w") input.forward=false;
  if(e.key==="s") input.back=false;
  if(e.key==="a") input.left=false;
  if(e.key==="d") input.right=false;
  if(e.key===" ") input.jump=false;
});

function updateArrows(inp){ /* dummy */ }
const rings = [];
const coins = [];
const water = {position:{y:-10}};
const playerId = 0;
const socket = null;
const room = null;
let coinsCollected = 0;
const coinCounterEl = document.getElementById("coinsValue");
let multiplierActive = false;
let multiplierExpireAt = 0;
const multTimeEl = document.getElementById("multTime");
const otherPlayers = new Map();
const otherCountEl = document.getElementById("otherCount");
const otherPlayersLabel = document.getElementById("otherPlayersLabel");
function grantMultiplier(sec){ multiplierActive=true; multiplierExpireAt=Date.now()+sec*1000; }
function setMultiplierActive(val){ multiplierActive=val; }
function hideAndScheduleRespawnLocal(id){}
function sendState(){}

/* ============================================================
   MAIN SCENE
============================================================ */
function createScene(){
  const scene = new BABYLON.Scene(engine);
  scene.clearColor = BABYLON.Color3.FromHexString(SETTINGS.skyColor);
  scene.enablePhysics(new BABYLON.Vector3(0,-9.81,0), new BABYLON.CannonJSPlugin());

  // DAY/NIGHT
  const sun = new BABYLON.DirectionalLight("sun", new BABYLON.Vector3(-1,-2,-1), scene);
  sun.position = new BABYLON.Vector3(50, 100, 50);
  sun.intensity = 1.2;
  let dayTime = 0;
  scene.registerBeforeRender(()=>{
    dayTime += engine.getDeltaTime()*0.00002;
    if(dayTime>1) dayTime=0;
    const angle = dayTime * Math.PI*2;
    sun.direction = new BABYLON.Vector3(Math.sin(angle), -Math.cos(angle), Math.cos(angle));
    sun.intensity = BABYLON.Scalar.Clamp(Math.cos(angle)+0.3,0.1,1.2);
    const dayColor = new BABYLON.Color3(0.6,0.9,1);
    const nightColor = new BABYLON.Color3(0.02,0.02,0.1);
    const blend = BABYLON.Scalar.Clamp(Math.cos(angle)+0.5,0,1);
    scene.clearColor = BABYLON.Color3.Lerp(nightColor,dayColor,blend);
  });

  // GROUND
  const groundSize = 300;
  const groundHeight = 10;
  const ground = BABYLON.MeshBuilder.CreateBox("ground",{width:groundSize,height:groundHeight,depth:groundSize},scene);
  ground.position.y = -groundHeight/2;
  const matTop = new BABYLON.StandardMaterial("matTop", scene);
  matTop.diffuseColor = BABYLON.Color3.FromHexString(SETTINGS.groundTopColor);
  const matSide = new BABYLON.StandardMaterial("matSide", scene);
  matSide.diffuseColor = BABYLON.Color3.FromHexString(SETTINGS.groundSideColor);
  const multi = new BABYLON.MultiMaterial("groundMulti", scene);
  multi.subMaterials = [matSide, matSide, matSide, matSide, matTop, matSide];
  ground.material = multi;
  ground.subMeshes = [];
  const vertices = ground.getTotalVertices();
  let indexStart = 0;
  for(let f=0; f<6; f++){ new BABYLON.SubMesh(f,0,vertices,indexStart,6,ground); indexStart+=6; }
  ground.physicsImpostor = new BABYLON.PhysicsImpostor(ground, BABYLON.PhysicsImpostor.BoxImpostor,{ mass:0, friction:2, restitution:0 },scene);

  // PLAYER
  const sphere = BABYLON.MeshBuilder.CreateSphere("player",{diameter:2},scene);
  sphere.position.set(0,3,0);
  const sphereMat = new BABYLON.StandardMaterial("sphereMat", scene);
  sphereMat.diffuseColor = new BABYLON.Color3(0.2,0.6,1);
  sphere.material = sphereMat;
  sphere.physicsImpostor = new BABYLON.PhysicsImpostor(sphere, BABYLON.PhysicsImpostor.SphereImpostor,{ mass:1, friction:0.6, restitution:0.05 },scene);

  // RAMPS
  const ramps=[]; const rampTriggers=[];
  for(const r of RAMPS){
    const ramp=makeTriRamp(scene);
    ramp.position.set(r.x,1.8,r.z);
    ramp.rotation.y = r.rotY;
    ramps.push(ramp);
    const depth = ramp._rampParams.depth || 4;
    const forward = new BABYLON.Vector3(Math.sin(r.rotY),0,Math.cos(r.rotY));
    const worldTrigger = ramp.position.add(forward.scale((depth/2)+1.5)).add(new BABYLON.Vector3(0,1.8,0));
    rampTriggers.push({ ramp, worldTrigger, forward });
  }
  function onRampBoost(trigger){
    const v = sphere.physicsImpostor.getLinearVelocity();
    const impulse = trigger.forward.normalize().scale(8);
    sphere.physicsImpostor.setLinearVelocity(new BABYLON.Vector3(impulse.x,12,impulse.z));
  }

  // PYRAMIDS
  const pyramids = [];
  const pyramidCount = 12;
  for(let i=0;i<pyramidCount;i++){
    let x,z,tries=0;
    do{
      x=rndRange(-groundSize/2+10,groundSize/2-10);
      z=rndRange(-groundSize/2+10,groundSize/2-10);
      tries++;
    } while(Math.hypot(x,z)<SETTINGS.safeRadius && tries<200);
    const pyramid=BABYLON.MeshBuilder.CreateCylinder("pyramid"+i,{diameterTop:0,diameterBottom:6,height:6,tessellation:4},scene);
    pyramid.position.set(x,3,z);
    const pMat = new BABYLON.StandardMaterial("pMat"+i,scene);
    pMat.diffuseColor = new BABYLON.Color3(0.9,0.75,0.3);
    pyramid.material=pMat;
    pyramid.physicsImpostor = new BABYLON.PhysicsImpostor(pyramid,BABYLON.PhysicsImpostor.MeshImpostor,{mass:0,friction:1,restitution:0},scene);
    pyramids.push(pyramid);
  }

  // TREES
  const trees=[];
  for(let i=0;i<SETTINGS.treeCount;i++){
    let x,z,tries=0;
    do{ x=rndRange(-groundSize/2+8,groundSize/2-8); z=rndRange(-groundSize/2+8,groundSize/2-8); tries++; }
    while((Math.hypot(x,z)<18 || SPAWN_ZONES.some(s=>Math.hypot(x-s.x,z-s.z)<s.r+4)) && tries<400);
    const trunk = BABYLON.MeshBuilder.CreateCylinder("trunk"+i,{height:3,diameterTop:0.6,diameterBottom:0.8,tessellation:8},scene);
    trunk.position.set(x,1.5,z);
    const trunkM = new BABYLON.StandardMaterial("trunkM"+i,scene); trunkM.diffuseColor=new BABYLON.Color3(0.35,0.25,0.12); trunk.material=trunkM;
    trunk.physicsImpostor = new BABYLON.PhysicsImpostor(trunk,BABYLON.PhysicsImpostor.NoImpostor,{mass:0});
    const foliage = BABYLON.MeshBuilder.CreateCylinder("leaf"+i,{height:4,diameterTop:0,diameterBottom:3,tessellation:12},scene);
    foliage.position.set(x,4.0,z);
    const leafM = new BABYLON.StandardMaterial("leafM"+i,scene); leafM.diffuseColor=BABYLON.Color3.FromHexString(SETTINGS.groundTopColor); foliage.material=leafM;
    foliage.physicsImpostor = new BABYLON.PhysicsImpostor(foliage,BABYLON.PhysicsImpostor.NoImpostor,{mass:0});
    trees.push({trunk,foliage});
  }

  // CAMERA
  const camera = new BABYLON.ArcRotateCamera("cam",0,BABYLON.Tools.ToRadians(55),14,sphere.position.clone(),scene);
  camera.attachControl(canvas,true);
  camera.lowerRadiusLimit=6; camera.upperRadiusLimit=40;

  // RETURN SCENE
  return scene;
}

/* ============================================================
   START ENGINE
============================================================ */
const scene = createScene();
engine.runRenderLoop(()=> scene.render());
window.addEventListener("resize",()=>engine.resize());
</script>
</body>
</html>
